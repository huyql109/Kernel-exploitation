_ copy_to_user() has a specific pagefault handler => not panic when encounter a valid address => use it to bruteforce kernel base

Exploit approach:
_ create an engine and allocate 254 compartments (its usage is 255)
_ create another engine with 255 compartments (when we race, it takes more time to search through list compartments to find empty slot => extend race window) 
_ race condition lead to integer overflow => it will free engine pointer
_ now we have compartmens with contain a freed pointer of engine
_ from now we have 2 approaches:
    + idiot way:
        . allocate a msg_msg struct with size == engine size, overwrite a kernel_base address to the logs pointer
        . call show_engine_log(), copy_to_user() fails gratefully when access invalid address => we can bruteforce kernel_base
    + smart way:
        . create an engine but fail when copy name => it only free engine, not free logs => we have a valid logs pointer
        . allocate a msg_msg struct in that uaf engine
        . we already have a valid pointer in heap => write a byte (0xf0) to mtext of msg_msg => overwrite a byte to logs pointer
        . leak address through show_engine_log()
_ write to mtext to overwrite logs pointer with modprobe_path address => use update_engine_log() to write to modprobe_path