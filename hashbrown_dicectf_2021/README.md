# Hashbrown - dice ctf 2021

## Analyze

#### Kernel build config
```
CONFIG_SLAB_FREELIST_RANDOM=y
CONFIG_SLAB=y
CONFIG_FG_KASLR=y
```

#### Qemu run script
```
#!/bin/sh

exec qemu-system-x86_64 \
    -m 128M \
    -nographic \
    -kernel "/app/bzImage" \
    -append "console=ttyS0 loglevel=3 oops=panic panic=-1 pti=on kaslr" \
    -no-reboot \
    -cpu qemu64,+smep,+smap \
    -monitor /dev/null \
    -initrd "/app/initramfs.cpio" \
    -smp 2 \
    -smp cores=2 \
    -smp threads=1
``` 

#### Mitigations
- SMEP, SMAP, KPTI, KASLR
- Reading kernel config, we know that this FGKASLR (see kernel rop in hxp 2020 for more info), Freelist randomize. 
- Use slab instead of slub.

#### Idea

- Kernel booted with `smp cores=2` => maybe race condition

#### Source code

##### Structure

```c
typedef struct 
{
    uint32_t key;
    uint32_t size;
    char *src;
    char *dest;
}request_t;

struct hash_entry
{
    uint32_t key;
    uint32_t size;
    char *value;
    struct hash_entry *next;
};

typedef struct
{
    uint32_t size;
    uint32_t threshold;
    uint32_t entry_count;
    hash_entry **buckets;
}hashmap_t;
```

- `request_t` for user input from userland, `hashmap_t` is a data structure containing a singly linked list of `hash_entry`
- Looking to the `hash_entry` struct, its size is 0x18 => kernel struct can be used are `seq_operations` or `shm_file_data`

##### Vulnerabilies

- race condition between resize() and other functions
- dangling pointer of `buckets` and `new_buckets`
#### Exploit strategy

Userfaultfd for the win

##### Leak through `shm_file_data`

- Spray `hash_entry` enough to reach `hashmap.threshold`
- Call `add_key()` with no duplicate key to trigger `resize()` and reach to `copy_from_user()` => trigger userfault 
- When the thread `resize()` is halting, another thread (userfaultfd) can call functions to modify `buckets`.
- In the `copy_from_user()` step in `resize()`, even when the `buckets` is modified by another thread, the `new buckets` still contains the uaf.
- So if we delete a value of a key in buckets, then create a `shm_file_data` struct in it, its still in the `new_buckets` which is eventually copied to `buckets`
- The reason we use `shm_file_data` is because `shmem_vm_ops` isnt effect by `FGKASLR`.
  
##### Overwrite `modprobe_path`

- Spray `hash_entry` enough to reach `hashmap.threshold`
- Call `add_key()` with no duplicate key to trigger `resize() and reach to `copy_from_user()` => trigger userfault
- When the thread `resize()` is halting, another thread (userfaultfd) can call functions to modify `buckets`.
- This case we can just delete a value of a target key => we create a dangling pointer of `hash_entry.value`. So the next call to create a `hash_entry`, its also stored in `hash_entry.value` of our target key.
- Because `resize_delete_old()` free many objects, we need continuous create new entry until we can find our target key's value
- When we find our 

