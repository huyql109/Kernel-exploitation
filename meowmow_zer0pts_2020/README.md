# meowmow - zer0pts ctf 2020

## Analize

### qemu script

```bash
#!/bin/sh
#!/bin/sh
qemu-system-x86_64 \
    -m 256M \
    -kernel ./bzImage \
    -initrd ./rootfs.cpio \
    -append "root=/dev/ram rw console=ttyS0 oops=panic panic=1 kaslr quiet" \
    -cpu kvm64,+smep,+smap \
    -monitor /dev/null \
    -nographic -enable-kvm \
```

=> smep, smap, kaslr

### lkm source code

**mod_open**:

```c
static int mod_open(struct inode *inode, struct file *file)
{
    if (memo == NULL) {
        memo = kmalloc(MAX_SIZE, GFP_KERNEL);
        memset(memo, 0, MAX_SIZE);
    }
    return 0;
}
```

**mod_read**:

```c
static ssize_t mod_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos)
{
    if (filp->f_pos < 0 || filp->f_pos >= MAX_SIZE) return 0;
    if (count < 0) return 0;
    if (count > MAX_SIZE) count = MAX_SIZE - *f_pos;
    if (copy_to_user(buf, &memo[filp->f_pos], count)) return -EFAULT;
    *f_pos += count;
    return count;
}
```

**mod_write**:

```c
static ssize_t mod_write(struct file *filp, const char __user *buf, size_t count, loff_t *f_pos)
{
    if (filp->f_pos < 0 || filp->f_pos >= MAX_SIZE) return 0;
    if (count < 0) return 0;
    if (count > MAX_SIZE) count = MAX_SIZE - *f_pos;
    if (copy_from_user(&memo[filp->f_pos], buf, count)) return -EFAULT;
    *f_pos += count;
    return count;
}
```

**mod_llseek**:

```c
static loff_t mod_llseek(struct file *filp, loff_t offset, int whence)
{
    loff_t newpos;
    switch(whence) {
    case SEEK_SET:
        newpos = offset;
        break;
    case SEEK_CUR:
        newpos = filp->f_pos + offset;
        break;
    case SEEK_END:
        newpos = strlen(memo) + offset;
        break;
    default:
        return -EINVAL;
    }
    if (newpos < 0) return -EINVAL;
    filp->f_pos = newpos;
    return newpos;
}
```

- Heap overflow in `mod_write` and `mod_read` => we can leak the kernel symbol in heap area.

- We have arbitrary read and write to the adjacent buffers so we need to places a struct right behind our heap chunk.

- Because the buffer is 0x400, kmalloc-1024 is used => we need a struct that also allocated by kmalloc-1024.

=> Choose `tty_struct` which is allocated by opening `/dev/ptmx`

```c
pwndbg> ptype /o struct tty_struct
/* offset    |  size */  type = struct tty_struct {
/*    0      |     4 */    int magic;
/*    4      |     4 */    struct kref {
/*    4      |     4 */        refcount_t refcount;
 
                               /* total size (bytes):    4 */
                           } cancer ;
/*    8      |     8 */    struct device *dev;
/*   16      |     8 */    struct tty_driver *driver;
/*   24      |     8 */    const struct tty_operations *ops;
/*   32      |     4 */    int index;
/* XXX  4-byte hole  */
/*   40      |    48 */    struct ld_semaphore {
/*   40      |     8 */        atomic_long_t count;
/*   48      |     0 */        raw_spinlock_t wait_lock;
/*   48      |     4 */        unsigned int wait_readers;
/* XXX  4-byte hole  */
/*   56      |    16 */        struct list_head {
/*   56      |     8 */            struct list_head *next;
/*   64      |     8 */            struct list_head *prev;
 
                                   /* total size (bytes):   16 */
                               } read_wait;
/*   72      |    16 */        struct list_head {
/*   72      |     8 */            struct list_head *next;
/*   80      |     8 */            struct list_head *prev;
 
                                   /* total size (bytes):   16 */
                               } write_wait;
 
                               /* total size (bytes):   48 */
                           } ldisc_ sem ;
/*   88      |     8 */    struct tty_ldisc *ldisc;
/*   96      |    24 */    struct mutex {
/*   96      |     8 */        atomic_long_t owner;
/*  104      |     0 */        spinlock_t wait_lock;
/*  104      |    16 */        struct list_head {
/*  104      |     8 */            struct list_head *next;
/*  112      |     8 */            struct list_head *prev;
 
                                   /* total size (bytes):   16 */
                               } wait_list;
 
                               /* total size (bytes):   24 */
                           } atomic_write_lock;
/*  120      |    24 */    struct mutex {
/*  120      |     8 */        atomic_long_t owner;
/*  128      |     0 */        spinlock_t wait_lock;
/*  128      |    16 */        struct list_head {
/*  128      |     8 */            struct list_head *next;
/*  136      |     8 */            struct list_head *prev;
 
                                   /* total size (bytes):   16 */
                               } wait_list;
 
                               /* total size (bytes):   24 */
                           } legacy_mutex;
/*  144      |    24 */    struct mutex {
/*  144      |     8 */        atomic_long_t owner;
/*  152      |     0 */        spinlock_t wait_lock;
/*  152      |    16 */        struct list_head {
/*  152      |     8 */            struct list_head *next;
/*  160      |     8 */            struct list_head *prev;
 
                                   /* total size (bytes):   16 */
                               } wait_list;
 
                               /* total size (bytes):   24 */
                           } throttle_mutex;
/*  168      |    24 */    struct rw_semaphore {
/*  168      |     8 */        atomic_long_t count;
/*  176      |    16 */        struct list_head {
/*  176      |     8 */            struct list_head *next;
/*  184      |     8 */            struct list_head *prev;
 
                                   /* total size (bytes):   16 */
                               } wait_list;
/*  192      |     0 */        raw_spinlock_t wait_lock;
 
                               /* total size (bytes):   24 */
                           } termios_rwsem;
/*  192      |    24 */    struct mutex {
/*  192      |     8 */        atomic_long_t owner;
/*  200      |     0 */        spinlock_t wait_lock;
/*  200      |    16 */        struct list_head {
/*  200      |     8 */            struct list_head *next;
/*  208      |     8 */            struct list_head *prev;
 
                                   /* total size (bytes):   16 */
                               } wait_list;
 
                               /* total size (bytes):   24 */
                           } winsize_mutex;
/*  216      |     0 */    spinlock_t ctrl_lock;
/*  216      |     0 */    spinlock_t flow_lock;
/*  216      |    44 */    struct ktermios {
/*  216      |     4 */        tcflag_t c_iflag;
/ * 220 | 4 * / tcflag_t c_oflag ;        
/*  224      |     4 */        tcflag_t c_cflag;
/*  228      |     4 */        tcflag_t c_lflag;
/*  232      |     1 */        cc_t c_line;
/*  233      |    19 */        cc_t c_cc[19];
/*  252      |     4 */        speed_t c_ispeed;
/*  256      |     4 */        speed_t c_ospeed;
 
                               /* total size (bytes):   44 */
                           } termios;
/*  260      |    44 */    struct ktermios {
/*  260      |     4 */        tcflag_t c_iflag;
/ * 264 | 4 * / tcflag_t c_oflag ;        
/*  268      |     4 */        tcflag_t c_cflag;
/*  272      |     4 */        tcflag_t c_lflag;
/*  276      |     1 */        cc_t c_line;
/*  277      |    19 */        cc_t c_cc[19];
/*  296      |     4 */        speed_t c_ispeed;
/*  300      |     4 */        speed_t c_ospeed;
 
                               /* total size (bytes):   44 */
                           } termios_locked;
/*  304      |     8 */    struct termiox *termiox;
/*  312      |    64 */    char name[64];
/*  376      |     8 */    struct pid *pgrp;
/*  384      |     8 */    struct pid *session;
/*  392      |     8 */    unsigned long flags;
/*  400      |     4 */    int count;
/*  404      |     8 */    struct winsize {
/*  404      |     2 */        unsigned short ws_row;
/*  406      |     2 */        unsigned short ws_col;
/*  408      |     2 */        unsigned short ws_xpixel;
/*  410      |     2 */        unsigned short ws_ypixel;
 
                               /* total size (bytes):    8 */
                           } winsize;
/*  412: 0   |     8 */    unsigned long stopped : 1;
/*  412: 1   |     8 */    unsigned long flow_stopped : 1;
/* XXX  6-bit hole   */
/* XXX  3-byte hole  */
/*  416: 0   |     8 */    unsigned long unused : 62;
/* XXX  2-bit hole   */
/*  424      |     4 */    int hw_stopped;
/*  428: 0   |     8 */    unsigned long ctrl_status : 8;
/*  429: 0   |     8 */    unsigned long packet : 1;
/* XXX  7-bit hole   */
/* XXX  2-byte hole  */
/*  432: 0   |     8 */    unsigned long unused_ctrl : 55;
/* XXX  1-bit hole   */
/* XXX  1-byte hole  */
/*  440      |     4 */    unsigned int receive_room;
/*  444      |     4 */    int flow_change;
/*  448      |     8 */    struct tty_struct *link;
/*  456      |     8 */    struct fasync_struct *fasync;
/*  464      |    16 */    wait_queue_head_t write_wait;
/*  480      |    16 */    wait_queue_head_t read_wait;
/*  496      |    32 */    struct work_struct {
/*  496      |     8 */        atomic_long_t data;
/*  504      |    16 */        struct list_head {
/*  504      |     8 */            struct list_head *next;
/*  512      |     8 */            struct list_head *prev;
 
                                   /* total size (bytes):   16 */
                               } entry;
/*  520      |     8 */        work_func_t func;
 
                               /* total size (bytes):   32 */
                           } hangup_work;
/*  528      |     8 */    void *disc_data;
/*  536      |     8 */    void *driver_data;
/*  544      |     0 */    spinlock_t files_lock;
/*  544      |    16 */    struct list_head {
/*  544      |     8 */        struct list_head *next;
/*  552      |     8 */        struct list_head *prev;
 
                               /* total size (bytes):   16 */
                           } tty_files;
/*  560      |     4 */    int closing;
/* XXX  4-byte hole  */
/*  568      |     8 */    unsigned char *write_buf;
/*  576      |     4 */    int write_cnt;
/* XXX  4-byte hole  */
/*  584      |    32 */    struct work_struct {
/*  584      |     8 */        atomic_long_t data;
/*  592      |    16 */        struct list_head {
/*  592      |     8 */            struct list_head *next;
/*  600      |     8 */            struct list_head *prev;
 
                                   /* total size (bytes):   16 */
                               } entry;
/*  608      |     8 */        work_func_t func;
 
                               /* total size (bytes):   32 */
                           } SAK_work;
/*  616      |     8 */    struct tty_port *port;
 
                           /* total size (bytes):  624 */
                         }

```

