#include <linux/fs.h>
#include <linux/init.h>
#include <linux/kernel.h>
#include <linux/miscdevice.h>
#include <linux/module.h>
#include <linux/slab.h>
#include <linux/uaccess.h>

#define CMD_READ 0x4000
#define CMD_WRITE 0x4001

#define MAX_DATA_LEN 0x400

static DEFINE_MUTEX(clipboard_mutex);

MODULE_AUTHOR("wxrdnx");
MODULE_LICENSE("GPL");

typedef struct query {
    pid_t pid;
    unsigned short length;
    char data[MAX_DATA_LEN];
} Query;

char *clipboard_data;

int clipboard_open(struct inode *inode, struct file *file) {
    clipboard_data = kmalloc(MAX_DATA_LEN, GFP_KERNEL);
    if (!clipboard_data) {
        printk(KERN_ERR "Clipboard: kmalloc error\n");
        return -1;
    }
    memset(clipboard_data, 0, MAX_DATA_LEN);
    return 0;
}
    
int check_read_query(Query *query) {
    unsigned short q_length;
    pid_t q_pid, c_pid;

    if (copy_from_user(&q_length, &query->length, sizeof(unsigned short))) {
        return 0;
    }

    c_pid = task_tgid_nr(current);
    if (copy_from_user(&q_pid, &query->pid, sizeof(pid_t))) {
        return 0;
    }
    return q_length <= MAX_DATA_LEN && q_pid == c_pid;
}

int read_clipboard_data(Query *query) {
    unsigned short q_length, i;

    if (copy_from_user(&q_length, &query->length, sizeof(unsigned short))) {
        return -1;
    }
    for (i = 0; i < q_length; i++) {
        if (copy_to_user(&query->data[i], &clipboard_data[i], 1)) {
            return i;
        }
    }
    return q_length;
}

int check_write_query(Query *query) {
    unsigned short q_length;
    pid_t q_pid, c_pid;

    if (copy_from_user(&q_length, &query->length, sizeof(unsigned short))) {
        return 0;
    }

    c_pid = task_tgid_nr(current);
    if (copy_from_user(&q_pid, &query->pid, sizeof(pid_t))) {
        return 0;
    }
    return q_length <= MAX_DATA_LEN && q_pid == c_pid;
}

int write_clipboard_data(Query *query) {
    unsigned short q_length, i;

    if (copy_from_user(&q_length, &query->length, sizeof(unsigned short))) {
        return 0;
    }
    for (i = 0; i < q_length; i++) {
        if (copy_from_user(&clipboard_data[i], &query->data[i], 1)) {
            return i;
        }
    }
    return q_length;
}

long clipboard_ioctl(struct file *file, unsigned int cmd, unsigned long arg) {
    long ret = -1;
    Query *query;

    mutex_lock(&clipboard_mutex);

    query = (Query *)arg;
    switch (cmd) {
        case CMD_READ:
            if (check_read_query(query)) {
                ret = read_clipboard_data(query);
            }
            break;
        case CMD_WRITE:
            if (check_write_query(query)) {
                ret = write_clipboard_data(query);
            }
            break;
        default:
            printk(KERN_ERR "Clipboard: Unknown command %x\n", cmd);
            break;
    }

    mutex_unlock(&clipboard_mutex);
    return ret;
}

int clipboard_release(struct inode *inode, struct file *file) {
    kfree(clipboard_data);
    return 0;
}

static const struct file_operations clipboard_fops = {
    .owner          = THIS_MODULE,
    .open           = clipboard_open,
    .unlocked_ioctl = clipboard_ioctl,
    .release        = clipboard_release
};

static struct miscdevice clipboard_device = {
    .minor = MISC_DYNAMIC_MINOR,
    .name = "clipboard",
    .fops = &clipboard_fops,
};

static int __init clipboard_init(void) {
    return misc_register(&clipboard_device);
}

static void __exit clipboard_exit(void) {
    misc_deregister(&clipboard_device);
}

module_init(clipboard_init);
module_exit(clipboard_exit);
